---
'tags': ['nsi', 'exercices']
---

## Ecrire de l'assembleur sur un simulateur

La page suivante propose d'écrire quelques programmes en assembleur.

<https://pixees.fr/informatiquelycee/n_site/nsi_prem_sim_cpu.html>

Elle utilise la simulation de Peter Higginson qui simule le langage assembleur AQA.

http://www.peterhigginson.co.uk/AQA/

## De python à l'assembleur

 Voici un programme Python très simple :

```
x = 4
y = 8
if x == 10:
	y = 9
else :
	x=x+1
z=6
```
			

et voici maintenant voici son équivalent en assembleur :

```asm
   MOV R0, #4
   STR R0,30
   MOV R0, #8
   STR R0,75
   LDR R0,30
   CMP R0, #10
   BNE else
   MOV R0, #9
   STR R0,75
   B endif
else:
   LDR R0,30
   ADD R0, R0, #1
   STR R0,30
endif:
   MOV R0, #6
   STR R0,23
   HALT
```			

Après avoir analysé très attentivement le programme en assembleur ci-dessus, vous essaierez
d'établir une correspondance entre les lignes du programme en Python et les lignes du programme en
assembleur. À quoi sert la ligne "B endif" ? À quoi correspondent les adresses mémoires 23, 75 et
30 ?

Source: pixees.fr CC-BY-SA


#### AIDE: L'ensemble d'instructions AQA

Voici une traduction de la documentation proposée à partir du bouton [INFO](http://www.peterhigginson.co.uk/AQA/info.html)

Les registres sont numérotés de `R0` à `R12`.

Les opérations peuvent être effectuées sur deux types de valeurs (notées `<opérande2>` dans la suite):

- une constante notée `#nnn`. Ex: `#12`: la valeur décimale 12.
- le contenu du régistre n `Rn`. Ex: `R1`: la valeur contenie dans le registre 1.

On peut ajouter des étiquettes dans le programme (notées `<label>`); il suffit de noter le nom de
l'étiquette de son choix et de le faire suivre de deux points. 

exemple:

```asm test: ```

Toute référence à cette étiquette fera "sauter" le programme à la case mémoire de
l'étiquette et exécutera donc les instructions qui suivent.

les commentaires commencent par au moins un `/`.

##### Affectations

- `LDR Rd, <adresse mémoire>`

Charge la valeur stockée dans l'emplacement de mémoire spécifié par `<adresse mémoire>` dans le
registre d.

- `STR Rd, <adresse mémoire>`

Stocke la valeur qui se trouve dans le registre d dans l'emplacement de mémoire spécifié par
`<adresse mémoire>`.

- `MOV Rd, <opérande2>`

Copiez la valeur spécifiée par `<opérande 2>`dans le registre d.


##### Opérations

- `ADD Rd, Rn, <opérande2>`

Ajouter la valeur spécifiée dans `<opérande 2>`à la valeur du registre 
n et stocker le résultat dans le registre d.

- `SUB Rd, Rn, <opérande2>`

Soustrayez la valeur spécifiée par `<opérande 2>`de la valeur du 
registre n et stockez le résultat dans le registre d.

##### Comparaisons

- `CMP Rn, <opérande2>`

Comparez la valeur stockée dans le registre n avec la valeur spécifiée 
par `<opérande 2>`

- `B <condition> <label>`

Connectez conditionnellement l'instruction à la position `<label>` dans
le programme si la dernière comparaison a répondu aux critères spécifiés par la `<condition>`. Les
valeurs possibles pour `<condition>` et leur signification sont les suivantes:
   - `EQ`: égal à,
   - `NE`: différent de,
   - `GT`: supérieur à,
   - `LT`: inférieur à. 

##### Sauts(JUMP)

- `B <label>`

Toujours relier l'instruction à la position `<label>` dans le programme.

##### Fin du programme

- `HALT`: Arrête l'exécution du programme.

##### Non utilisées dans ce TD

- `AND Rd, Rn, <opérande2>`:

Effectue une opération ET logique au niveau du bit entre la valeur du 
registre n et la valeur spécifiée par `<opérande 2>` et stocke le résultat dans le registre d.

- `ORR Rd, Rn, <opérande2>`:

Effectue une opération OU logique au niveau des bits entre la
valeur du registre n et la valeur spécifiée par `<opérande 2>`et stocke le résultat dans le registre
d.

- `EOR Rd, Rn, <opérande2>`:

Effectue une opération logique ou binaire exclusive au sens des bits
entre la valeur du registre n et la valeur spécifiée par `<opérande 2>`et stocke le résultat dans le
registre d.

- `MVN Rd, <opérande2>`:

Exécutez une opération NOT logique au niveau des bits sur la valeur
spécifiée par `<opérande 2>`et stockez le résultat dans le registre d.

- `LSL Rd, Rn, <opérande2>`:

Décalez logiquement vers la gauche la valeur stockée dans le registre
n du nombre de bits spécifié par `<opérande 2>` et stockez le résultat dans le registre d.

- `LSR Rd, Rn, <opérande2>`:

Décalez logiquement à droite la valeur stockée dans le registre n du 
nombre de bits spécifié par `<opérande 2>` et stockez le résultat dans le registre d.

#### Sources

- https://pixees.fr/informatiquelycee/n_site/nsi_prem_sim_cpu.html
- http://www.lyceerotroudreux.com/images/NSI/Langage_Assembleur.pdf
- http://www.peterhigginson.co.uk/AQA/info.html