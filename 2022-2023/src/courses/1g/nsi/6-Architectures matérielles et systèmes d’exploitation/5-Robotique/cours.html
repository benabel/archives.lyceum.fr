<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.290">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>cours</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="cours_files/libs/clipboard/clipboard.min.js"></script>
<script src="cours_files/libs/quarto-html/quarto.js"></script>
<script src="cours_files/libs/quarto-html/popper.min.js"></script>
<script src="cours_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="cours_files/libs/quarto-html/anchor.min.js"></script>
<link href="cours_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="cours_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="cours_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="cours_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="cours_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<details class="programme"><summary>Programme Officiel</summary>
<table class="table table-bordered table-hover">
<thead class="table-warning">
<tr class="header">
<th>Contenus</th>
<th>Capacités attendues</th>
<th>Commentaires</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>Périphériques d’entrée et de sortie</p>
<p>Interface Homme- Machine (IHM)</p></td>
<td><p>Identifier le rôle des capteurs et actionneurs.</p>
<p>Réaliser par programmation une IHM répondant à un cahier des charges donné.</p></td>
<td>Les activités peuvent être développées sur des objets connectés, des systèmes embarqués ou robots.</td>
</tr>
</tbody>
</table>
<a class="lien-programme" href="../programme/">Lien vers le programme complet</a></details>

<p>Dans ce chapitre, nous allons aborder l’utilisation de périphériques d’entrée et de sortie dans le cadre de la robotique en utilisant des robots éducatifs Lego NXT.</p>
<p>A la différence d’un simple ordinateur, les robots sont capables d’interagir avec le monde extérieur en utilisant:</p>
<ul>
<li>des <strong>capteurs</strong>, il s’agit de <em>périphériques d’entrée</em> permettant de mesurer divers paramètres extérieurs( lumière, distance, température…)</li>
<li>des <strong>actionneurs</strong>, il s’agit de <em>périphériques de sortie</em>(moteurs, vérins, bras motorisés) permettant d’agir sur le monde extérieur en réponse au programme implémenté dans le robot.</li>
</ul>
<p>Pour vous aider tout au long de cette partie, vous disposez de la <a href="./images/noticeang-nxt.pdf">notice</a> du robot en anglais auquel le texte du TP se réfère.</p>
<p>Cependant, si vous n’êtes pas à l’aise avec l’anglais, l’association robotique de Sophia-Antipolis <a href="https://pobot.org">pobot.org</a> propose également un excellent <a href="https://www.pobot.org/IMG/pdf/hasparren-tutorial_nxtg-v2.pdf">tutoriel</a> pour utiliser le robot nxt.</p>
<h2 id="réaliser-le-montage-du-robot" class="anchored">Réaliser le montage du robot</h2>
<p>Le robot est peut-être en partie monté, utiliser l’image suivante pour le vérifier. Si besoin vous référer à la notice officielle.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/nxt-chenillard.png" class="quarto-discovered-preview-image img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">robot chenillard</figcaption><p></p>
</figure>
</div>
<p>Mettre en place les capteurs</p>
<ul>
<li>de contact (vers l’avant du robot)</li>
<li>de couleur (vers le sol, à 0,5 cm du sol environ)</li>
</ul>
<p>[[plus|S’il vous reste du temps]] | |- Réaliser les tests de fonctionnement de ces capteurs proposés dans la notice (aux pages 26 et 27) |- Pour faire de la place en mémoire, effacer les programmes ajoutés par les élèves avant vous: menu NXT Files (my files)</p>
<h2 id="utilisation-du-logciel-ev3" class="anchored">Utilisation du logciel EV3</h2>
<p>Vous allez apprendre à configurer un projet dans le logiciel EV3, puis réaliserez quelques tests sur vos capteurs avant de créer votre premier programme, le très classique suiveur de lignes.</p>
<p>N’oubliez pas de prendre des notes au fur et à mesure de vos avancées.</p>
<h3 id="configuration-du-projet" class="anchored">Configuration du projet</h3>
<ul>
<li><p>Lancer le logiciel EV3. Cliquer sur l’onglet + en haut à gauche pour démarrer un nouveau projet.</p>
<img src="./images/demarrerprojet.png" class="img-fluid" alt="démarrer projet"></li>
<li><p>Connecter le robot sur un port USB à l’aide d’un câble approprié. Démarrer le robot pour qu’il soit détecté par le logiciel</p></li>
<li><p>Ouvrir l’aide EV3 et suivre le tutoriel sur les généralités.</p>
<img src="./images/généralités.png" class="img-fluid" alt="généralités"></li>
<li><p>Sur la “Page du Matériel” : lire attentivement les explications pour renseigner les ports sur lesquels vous avez branchés les 2 moteurs (B et C), le gros moteur central (A), le capteur de contact (port 1 ou 2) et le capteur de couleur (port3)</p>
<img src="./images/aide_matériel.png" class="img-fluid" alt="page du matériel">
<p>Configurez le projet dans la fenêtre matériel avec ces renseignements</p></li>
</ul>
<h3 id="réalisation-des-tests" class="anchored">Réalisation des tests</h3>
<ul>
<li><p>Réalisez alors des tests sur votre robot et lire les valeurs affichées pour le capteur de contact, lorsqu’il est :</p></li>
<li><p>enfoncé</p></li>
<li><p>relâché</p></li>
<li><p>Réalisez les tests sur votre robot et lire les valeurs affichées pour le capteur de couleur lorsque l’on dispose sous le capteur un objet de couleur</p></li>
<li><p>bleu</p></li>
<li><p>vert</p></li>
<li><p>rouge</p></li>
<li><p>jaune</p></li>
<li><p>Réalisez les tests sur ce même capteur de couleur, mais en mode “mesure d’intensité ambiante”. Noter la valeur lorsque l’on dispose devant le capteur un objet :</p></li>
<li><p>Blanc</p></li>
<li><p>Noir</p></li>
<li><p>Refaire le même test, mais cette fois ci en mode “mesure d’intensité réfléchie” (le capteur émettant de la lumière rouge)</p></li>
<li><p>Consignez tous vos résultats par écrit dans votre cahier : capteurs, ports, conditions d’essais, résultats</p></li>
<li><p>Sur la page de l’aide : Programmes : Familiarisez vous avec la programmation par “briques”</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/programmation_briques.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">programmation briques</figcaption><p></p>
</figure>
</div>
<h2 id="le-suiveur-de-ligne" class="anchored">Le suiveur de ligne</h2>
<p>Le texte original du TP est à l’adresse suivante :</p>
<p><a href="http://www.sitedunxt.fr/articles/articles-4-9-3+faire-du-suivi-de-ligne.php" class="uri">http://www.sitedunxt.fr/articles/articles-4-9-3+faire-du-suivi-de-ligne.php</a></p>
<p>Le TP proposé ici a été adapté pour le logiciel EV3, plus récent.</p>
<p>Le principe de notre programme sera le suivant. Initialement, le robot sera placé de telle sorte qu’il soit centré sur la ligne noire. Le capteur de lumière se trouvant juste au dessus de celle-ci.</p>
<p>Nous allons faire avancer notre robot tout en le faisant tourner d’un côté ou d’un autre.</p>
<p>Lorsqu’il détectera une couleur noire, il avancera en tournant vers la droite. De ce fait, ce léger virage déplacera le capteur de lumière vers un côté de la ligne et il se retrouvera à un moment au dessus de la couleur blanche.</p>
<p>Le robot aura tout simplement sorti de l’axe de la ligne.</p>
<p>Lorsqu’il détectera une autre couleur que le noir, comme par exemple la couleur blanche de la planche de test, il avancera en tournant cette fois ci vers la gauche.</p>
<p>Ainsi, le robot reviendra vers l’axe de la ligne noire et il aura avancé car les deux roues auront tournées dans le même sens sur une courte distance.</p>
<p>Le capteur repassant au dessus de la ligne noire, il aura donc fait un cycle complet, à savoir, être sur la ligne puis s’en éloigner et enfin revenir vers cette même ligne.</p>
<p>Le cœur du programme est là. Il ne suffira plus qu’à faire effectuer ce cycle au robot de manière permanente.</p>
<h3 id="réalisation-du-programme" class="anchored">Réalisation du programme</h3>
<p>Commençons par placer une boucle infinie au début de notre programme. En effet, le suivi de ligne va se faire en permanence :</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/boucle_infinie.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">boucle infinie</figcaption><p></p>
</figure>
</div>
<p>Puis, placez à l’intérieur de cette boucle un bloc “Commutation” paramétré sur le capteur de couleur et réglé sur la couleur noire :</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/capteurtest.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">capteurTest</figcaption><p></p>
</figure>
</div>
<p>Vous devez ici choisir l’option Capteur photosensible du paramètre Action et sélectionner le signe &lt; (plus petit que) dans le paramètre Comparer, en sélectionnant le bouton de gauche représenté par une lumière sombre, de manière à indiquer au bloc “Commutation” d’exécuter le rayon de séquence supérieur (b) condition vrai[/b]) lorsque le capteur de lumière renverra une valeur de luminosité inférieur à la valeur de déclenchement indiqué dans le champ de saisie situé à droite. Cette valeur de déclenchement a une valeur de 50 par défaut. Vous pouvez changer ce réglage.</p>
<p>Si le capteur identifie devant lui une couleur noire, celle de la ligne, la condition est vrai et le bloc “Commutation” exécutera le bloc placé sur le rayon de séquence supérieur.</p>
<p>Nous allons utiliser un bloc “Déplacement et direction” pour contrôler les deux moteurs de propulsion et le configurer de tel manière que le robot tourne vers la droite : Dans la partie supérieure du bloc de commutation, ajouter le bloc et paramétrer la direction (ici, j’ai choisi 30° de sorte que le robot continue à avancer et ne fasse pas que virer)</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/moteurs.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">moteurs</figcaption><p></p>
</figure>
</div>
<p>Puis le déplacement vers la gauche : partie inférieure du bloc.</p>
<p>Comme il est là, le programme pourrait fonctionner correctement.</p>
<p>Si le capteur mesure une valeur inférieure à 50, c’est à dire qu’une couleur sombre comme la couleur noire de la ligne se trouve en face de lui, le rayon de séquence supérieur est exécuté es le robot avance en tournant vers la droite.</p>
<p>Si le capteur mesure une valeur supérieure à 50, c’est à dire qu’une couleur claire comme la couleur blanche de la planche de test se trouve en face de lui, le rayon de séquence inférieur est exécuté et le robot avance en tournant vers la gauche.</p>
<p>Toutes les valeurs renvoyées par le capteur de lumière se trouvant supérieure à ce seuil, c’est à dire dans la plage de valeur allant de 50 à 100, sont considérées comme faisant parties de la catégorie des couleurs claires. De même, toutes les valeurs inférieures à ce seuil allant de 0 à 49 sont considérées comme des couleurs sombres.</p>
<h2 id="comment-utiliser-des-variables-dans-le-logiciel-ev3" class="anchored">Comment utiliser des variables dans le logiciel EV3?</h2>
<p>Texte adapté du site du NXT :</p>
<p><a href="http://www.sitedunxt.fr/articles/articles-4-25-2+les-variables-et-les-constantes.php" class="uri">http://www.sitedunxt.fr/articles/articles-4-25-2+les-variables-et-les-constantes.php</a></p>
<p>Dans cette partie du tutoriel consacrée au NXT-G, nous allons aborder le sujet très important que sont les variables et les constantes.</p>
<p>C’est grâce à ces variables notamment que vos programmes pourront être encore plus complexes et intelligents.</p>
<p>Contrairement au langage Python, dans EV3, la déclaration de variable est <strong>obligatoire</strong> et doit être faite avant toutes utilisations des variables.</p>
<p>Si vous ne faites pas de déclaration de variable, vous ne pourrez tous simplement pas utiliser cette variable dans votre programme.</p>
<blockquote class="blockquote">
<p>Pour déclarer une variable, il faut utiliser le bloc « Variable » (rouge), et cliquer dans le coin supérieur droit : Un menu affiche alors « Ajouter variable »</p>
</blockquote>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/lumiere1.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">lumière1</figcaption><p></p>
</figure>
</div>
<p>Renseigner alors le nom de la variable, par exemple « lumiere » pour notre exemple.</p>
<p>Le bouton en bas à gauche du bloc de configuration vous permet de préciser l’action :</p>
<ul>
<li>“Lire” la valeur contenue dans celle-ci ou pour “Ecrire” une valeur dans cette même variable.</li>
<li>“Ecrire”, le bloc “Variable” mémorise la valeur que vous entrez dans le champ nommé “Valeur” juste en dessous.</li>
</ul>
<p>Ici, vous sélectionnerez « écrire » et choisirez le type : « Numérique »</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/lumiere2.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">lumière2</figcaption><p></p>
</figure>
</div>
<blockquote class="blockquote">
<p>Ajouter un bloc « boucle » avec répétition infinie.</p>
<p>Ajouter un bloc de mesure de couleur (capteur de couleur)</p>
<p>Ajouter à nouveau le bloc variable « lumiere ». Si un fil de données est connecté au bloc “Variable”, la valeur transporté par ce fil de données est mémorisé dans la variable : connectez alors les 2 derniers blocs comme sur le schéma suivant :</p>
</blockquote>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/lumiere3.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">lumière3</figcaption><p></p>
</figure>
</div>
<p>Lorsque vous choisissez l’option “Lire”, le bloc “Variable” vous restitue la valeur de cette variable par l’intermédiaire d’un fil de données que vous pouvez utiliser dans votre programme.</p>
<p>Ici, la valeur mesurée par le capteur est mise dans la variable <code>lumiere</code></p>
<blockquote class="blockquote">
<p>Modifier ensuite le bloc capteur de couleur pour réaliser une mesure de l’intensité ambiante. Il faudra refaire le fil de données qui se sera effacé.</p>
</blockquote>
<p>Compléter alors le programme avec les blocs :</p>
<blockquote class="blockquote">
<p>« attendre ». Paramétrer sur 5s.</p>
<p>« Variable » : Paramétrer pour lire la valeur « numérique » de la variable « lumiere »</p>
<p>« Texte » : prolonger le fil de données depuis le bloc variable précédent et le relier à A.</p>
<p>« Afficher » : Le texte à afficher est dans le coin supérieur droit. Choisissez “Relié” comme valeur d’entrée Texte dans le coin supérieur droit du bloc pour afficher une valeur d’entrée Texte acceptant un fil de données. Relier ce fil de données dans la partie inférieure du bloc comme sur le schéma suivant.</p>
<p>« Attendre » : paramétrer sur 10s</p>
</blockquote>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/lumierecomplet.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">lumièrecomplet</figcaption><p></p>
</figure>
</div>
<h3 id="pour-aller-plus-loin" class="anchored">Pour aller plus loin</h3>
<p>Utiliser le fil de variable avec un sélecteur :</p>
<p>rappel : pour utiliser une variable : il faut d’abord la déclarer (bloc de variable : écrire)</p>
<p>Puis lire son contenu</p>
<p>Et enfin, créer un fil de variable depuis le bloc lecture vers le bloc sélecteur, comme sur le schéma ci dessous :</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/detect_lum.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">détecteur de lumière</figcaption><p></p>
</figure>
</div>
<p>On peut utiliser ce morceau de programme pour un projet : détection et recherche de la lumière par exemple : le robot devra retrouver la source de lumière à l’aide de conditions tests que vous devrez établir.</p>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copié");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copié");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>