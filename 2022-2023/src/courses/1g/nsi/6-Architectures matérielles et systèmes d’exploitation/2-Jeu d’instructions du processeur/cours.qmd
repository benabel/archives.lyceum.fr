---
tags: ["langage machine", "assembleur", "jeu d'instructions"]
---

::: programme
+-----------------------+---------------------------------+--------------------------------+
| Contenus              | Capacités attendues             | Commentaires                   |
+=======================+=================================+================================+
| Modèle d’architecture | Dérouler l’exécution d’une      | Des activités débranchées sont |
| séquentielle          | séquence d’instructions simples | proposées.                     |
| (von Neumann)         | du type langage machine.        |                                |
+-----------------------+---------------------------------+--------------------------------+
:::

::: intro

Maintenant que nous avons vu quelle était la structure générale d'un ordinateur, nous allons nous
intéresser plus précisément au rôle du processeur et de la mémoire(vive), et voir comment peuvent
être dictées les instructions à l'unité de contrôle du processeur.

![Copie d'écran de la simulation de Von Neumann utilisée.](../../images/vnsim.png)

:::

## Les divers éléments de la simulation

On utilisera dans ce cours une version modifiée de la simulation de Lorenzo Gianni sous licence
MIT.

<https://apps.lyceum.fr/vnsim>

Outre la RAM, le processeur ne possède qu'un très petit nombre de cases mémoires très rapides
appelées des *registres* dont la capacité dépasse rarement quelques dizaines d'octets pour des
raisons de coût et de place.
[Source Wikipédia](https://fr.wikipedia.org/wiki/Registre_de_processeur)


### La mémoire (RAM)

::: {layout-ncol=2}

La mémoire vive contient plusieurs milliards de circuits mémoires un bit, qui sont organisés en
*cases mémoires* de huit, seize, trente-deux, soixante-quatre bits. Chaque case a une *adresse*
unique, leur nombre détermine la capacité de la mémoire vive de l'ordinateur.

![La mémoire est située à droite est séparée en deux parties: le programme et ses instructions à gauche(adresses 0 à 99) et les variables(adresses 100 et suivantes) avec leurs données à droite.](../../images/vn-mem.png)

:::

### L'unité de commande (RI et CP)

::: {layout-ncol=2}

:::: left

L'unité de commande contient _deux registres_ pour stocker son état d'exécution:

- Le registre d'instruction (RI) stocke l'instruction du programme provenant de la mémoire programme actuellement exécutée.
- Le compteur de programme stocke la ligne du programme actuellement exécutée, après son exécution
  ce compteur est incrémenté de 1 (sauf en cas de saut: `JMP`).

::::

![L'unité de commande possède deux registres: le registre d'instructions et le compteur de programme.](../../images/vn-uc.png)

:::

### L'unité arithmétique et logique (UAL)

::: {layout-ncol=2}

:::: left

L'unité arithmétique et logique est composée de transistors assemblés de façon à lui permettre de réaliser un *petit nombre d'opérations simples (arithmétique: + -, logique booléenne: & | !), mais à réaliser ces opérations très rapidement*.

Le résultat des opérations est stocké dans un _registre_ appelé accumulateur (ACC).

::::

![Le résultat des opérations des circuits calculatoires de l'UAL est stocké dans l'accumulateur pour l'exécution de calculs ultérieurs ou pour être renvoyé vers la mémoire.](../../images/vn-ual.png)

:::


## Programmer en assembleur

Les cellules mémoire du programme sont stockées sous forme binaire, on les représente cependant
sous forme textuelle. Un compilateur les convertit ensuite sous forme binaire pour les stocker dans
la mémoire programme. Cette représentation textuelle est appelée le _langage assembleur_.

Le jeu d’instructions de notre simulateur est résumé ci-dessous.

:::{.list-table}
   * - []{colspan=3} Accès mémoire

   * - `LOAD var / LOAD #nb`
     - Transfère dans l'accumulateur la valeur de la variable `var` présente dans la mémoire ou
       directement le nombre `nb`.

   * - `STORE var`
     - Transfère le contenu de l'accumulateur dans l'adresse mémoire associée à la variable `var`.  
:::

::: appli

Écrire un programme qui permet de stocker quatre valeurs 2, 3, 5, 7 dans les cases mémoires
d'adresse 100(variable X), 101(Y), 102(Z), 103(W).

_Ne pas oublier d'ajouter l'instruction `HALT` en fin du programme pour arrêter l'incrémentation du
CP._

<!--
// Affectation des variables
LOAD #2
STORE X
LOAD #3
STORE Y
LOAD #5
STORE Z
LOAD #7
STORE W
HALT
-->

:::


:::{.list-table}
   * - []{colspan=2} Opérations arithmétiques
 
   * - `ADD var / ADD #nb`
     - _Additionne_ au contenu de l'accumulateur la valeur de la variable `var` de la mémoire ou
       directement le nombre `nb` et renvoie dans l'accumulateur le résultat.
   * - `SUB var / SUB #nb`
     - _Soustrait_ au contenu de l'accumulateur la valeur de la variable `var` de la mémoire ou
       directement le nombre `nb` et renvoie dans l'accumulateur le résultat.
:::

::: appli

Compléter le programme de l'application précédente pour additionner les quatre nombres contenus
dans les cases mémoires X, Y, Z et W et de stocker le résultat de cette addition dans la case
mémoire 104(N).

<!-- 
// Addition
LOAD X
ADD Y
ADD Z
ADD W
STORE N
HALT
-->

:::

:::{.list-table}
   * - []{colspan=3} Opération logique

   * - `CMP adr / CMP #nb`
     - Compare le contenu de l'accumulateur à la valeur de la variable `var` de la mémoire ou au
       nombre `nb` et renvoie dans l'accumulateur le résultat -1,0 ou 1 selon le résultat de la
       comparaison: inférieur, égal ou supérieur.
     
:::

::: appli

Compléter le programme de l'application précédente pour comparer le contenu des cases mémoires X et
N et de stocker le résultat de cette comparaison dans la case mémoire 6(R).

<!-- 
// Comparaison
LOAD X
CMP N
STORE R
HALT
-->

:::


::: {.callout-tip}
## Ajouter des étiquettes aux lignes du programme

Pour pouvoir réaliser des boucles ou sauter des lignes en fonction de conditions, on utilise des
instructions de saut `JMP` qui permettront de se déplacer vers une ligne spécifique du programme
ou vers une ligne précédée d'une étiquette `inf: LOAD X` ici l'étiquette est `inf` on peut s'y
rendre avec `JMP inf`.

:::



:::{.list-table}
   * - []{colspan=3} Contrôle du programme: Conditions, boucles, commentaires...

   * - `JMP étiquette / JMP n`
     - Transfère dans le compteur de programme _CP_ le numéro de ligne `n` ou le numéro de la ligne avec
       l'étiquette `étiquette`.

   * - `JMPZ étiquette / JMPZ n`
     - Transfère **uniquement si le contenu de l'accumulateur est nul** dans le compteur de
       programme _CP_ le numéro de ligne `n` ou le numéro de la ligne avec l'étiquette `étiquette`.

   * - `JMPN étiquette / JMPN n`
     - Transfère **uniquement si le contenu de l'accumulateur est négatif** dans le compteur de
       programme _CP_ le numéro de ligne `n` ou le numéro de la ligne avec l'étiquette `étiquette`.  

   * - `JMPP étiquette / JMPP n`
     - Transfère **uniquement si le contenu de l'accumulateur est positif** dans le compteur de
       programme _CP_ le numéro de ligne `n` ou le numéro de la ligne avec l'étiquette `étiquette`.

   * - `HALT`
     - Stoppe l'exécution du programme.

   * - `// commentaire`
     - Ligne de commentaire non exécutée.

   * - `INSTRUCTION X ; commentaire de ligne`
     - On peut ajouter des commentaires de lignes avec un point virgule.

:::





::: {.appli titre="Multiplication d'entiers positifs"}

Stocker deux entiers positifs quelconques dans les variables `X` et `Y`, puis sans utiliser
l'opérateur `MUL`, réaliser l'opération $X\times Y$ et stocker le résultat dans la case mémoire
105(variable R).

Pour cela on initialisera une variable `R` à 0 à laquelle on ajoutera `X` `Y` fois grâce à une
boucle. A chaque tour de boucle, ajouter `X` à `R`, soustraire 1 à `Y` tant que `Y` est positif
grâce à un `JMPP`.

<!-- 
// X x Y sans MUL

// initialisation variables
// X = 4
LOAD #4
STO X
// Y = 5
LOAD #5
STO Y
// R = 0
LOAD #0
STO R

// boucle
boucle: LOAD R
// R = R + Y
ADD Y
STO R
// X = X-1
LOAD X
SUB #1
STO X
// boucle tant que X > 0
JMPP boucle
HALT
-->

:::

::: {.appli titre="Multiplication d'entiers quelconques"}

Adapter l'algorithme précédent grâce à une condition:

- Si $Y > 0$: reprendre l'algorithme précédent.
- Si $Y < 0$: soustraire `X` `Y` fois grâce à une boucle.
- Si $Y = 0$: terminer le programme et laisser `R` à 0.


<!-- 
// initialisation variables
// X = 4
LOAD #-4
STO X
// Y = 5
LOAD #-5
STO Y

// R = 0
LOAD #0
STO R

// Condition sur X
LOAD X
// X > 0
JMPP boucle
// X < 0
JMPN boucleneg
// X = 0
JMPZ fin

// boucle X > 0
boucle: LOAD R
// R = R + Y
LOAD R
ADD Y
STO R
// X = X-1
LOAD X
SUB #1
STO X
// boucle tant que X > 0
JMPP boucle
JMPZ fin

// boucle X < 0
boucleneg: LOAD R
// R = R + Y
LOAD R
SUB Y
STO R
// X = X + 1
LOAD X
ADD #1
STO X
// boucle tant que X > 0
JMPN boucleneg

fin: HALT
-->

:::


::: ref

-   Chapitre 1: Au cœur de l'ordinateur
    [NSI Première Hachette 2021 sous la direction de Michel Beaudouin-Lafon](https://www.enseignants.hachette-education.com/livres/numerique-sciences-informatiques-1re-specialite-livre-eleve-ed-2021-9782017866305)

-   Chapitre 15: L'organisation d'un ordinateur
    [Informatique et sciences du numérique Spécialité ISN en terminale S - Avec des exercices corrigés et des idées de projets par Gilles Dowek](http://www.editions-eyrolles.com/Livre/9782212135435/)

:::