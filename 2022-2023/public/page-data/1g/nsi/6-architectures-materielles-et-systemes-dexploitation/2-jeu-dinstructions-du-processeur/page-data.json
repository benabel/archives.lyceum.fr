{"componentChunkName":"component---src-templates-cours-md-js","path":"/1g/nsi/6-architectures-materielles-et-systemes-dexploitation/2-jeu-dinstructions-du-processeur/","result":{"data":{"markdownRemark":{"html":"<details class=\"programme\"><summary>Programme Officiel</summary>\n<table class=\"table table-bordered table-hover\">\n<thead class=\"table-warning\">\n<tr class=\"header\">\n<th>Contenus</th>\n<th>Capacités attendues</th>\n<th>Commentaires</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>Modèle d’architecture séquentielle (von Neumann)</td>\n<td>Dérouler l’exécution d’une séquence d’instructions simples du type langage machine.</td>\n<td>Des activités débranchées sont proposées.</td>\n</tr>\n</tbody>\n</table>\n<a class=\"lien-programme\" href=\"../programme/\">Lien vers le programme complet</a></details>\n<div class=\"intro\">\n<p>Maintenant que nous avons vu quelle était la structure générale d’un ordinateur, nous allons nous intéresser plus précisément au rôle du processeur et de la mémoire(vive), et voir comment peuvent être dictées les instructions à l’unité de contrôle du processeur.</p>\n<div class=\"quarto-figure quarto-figure-center\">\n<figure class=\"figure\">\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 51.35135135135135%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAC4jAAAuIwF4pT92AAAB0ElEQVR42p2SyW4TQRRF/XdZIBYQYwskFrBl4T0Jg/gAfoRlBtjBnhVREsfx1EPcbnfX3INjyZ2DukSkSBYS4klXV/VKOrdeVXWOPr26+/H5Dd8+vuDkYJ/Twy4nB13vR2/3OX3X4+uH55y873N82OP4sO/Xr5894vGTLt3+S57u99jb22MwGDSdiyAltzWpqVjZNZldE6o1S10R6xq13iLLDUvlSKTzfiMM1hjW2TmN/sW2jGlrOBzSGc1CSmfQSqCVxCjJMpPkQqC1IskL4tQwv8kZhyvChSJMBFJqmlsHW8umNh54fT2mcz6JENqQ5i1EemicCjKhWQmFlAohJclKMQoki7TtSaq65r42m4330WhE52wckgpFph1ltfbAsqqxRcViJTBaoZXyYclKooxFCkH9ANg0jffJZNKOHFFY7e+k3WjuYLttCDPtT9oCpVIopTBGo7VG/AU4m83pXM0inDUIqbByQRl/x+Yzcmn9aOoP7KH+AagRUiOWE9KLL4hkiNYWpf4DOI0SbuuKwjnqqmZpG0xR45zFObejoii83z/EDvDn2VUzDm64moa0X2g4DYiiiDiOd9T2gyBgPp+TZRllWfoAa60PuLy83P4GMVDY1ichadkAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"vnsim\" title=\"\" src=\"/2022-2023/static/b71d93fede46db6a1f0fb6fee275e68d/fcda8/vnsim.png\" srcset=\"/2022-2023/static/b71d93fede46db6a1f0fb6fee275e68d/12f09/vnsim.png 148w,\n/2022-2023/static/b71d93fede46db6a1f0fb6fee275e68d/e4a3f/vnsim.png 295w,\n/2022-2023/static/b71d93fede46db6a1f0fb6fee275e68d/fcda8/vnsim.png 590w,\n/2022-2023/static/b71d93fede46db6a1f0fb6fee275e68d/efc66/vnsim.png 885w,\n/2022-2023/static/b71d93fede46db6a1f0fb6fee275e68d/c83ae/vnsim.png 1180w,\n/2022-2023/static/b71d93fede46db6a1f0fb6fee275e68d/133ae/vnsim.png 1424w\" sizes=\"(max-width: 590px) 100vw, 590px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span></p>\n<p></p><figcaption class=\"figure-caption\">Copie d’écran de la simulation de Von Neumann utilisée.</figcaption><p></p>\n</figure>\n</div>\n</div>\n<h2 id=\"les-divers-éléments-de-la-simulation\" class=\"anchored\">Les divers éléments de la simulation</h2>\n<p>On utilisera dans ce cours une version modifiée de la simulation de Lorenzo Gianni sous licence MIT.</p>\n<p><a href=\"https://apps.lyceum.fr/vnsim\" class=\"uri\">https://apps.lyceum.fr/vnsim</a></p>\n<p>Outre la RAM, le processeur ne possède qu’un très petit nombre de cases mémoires très rapides appelées des <em>registres</em> dont la capacité dépasse rarement quelques dizaines d’octets pour des raisons de coût et de place. <a href=\"https://fr.wikipedia.org/wiki/Registre_de_processeur\">Source Wikipédia</a></p>\n<h3 id=\"la-mémoire-ram\" class=\"anchored\">La mémoire (RAM)</h3>\n<div class=\"quarto-layout-panel\">\n<div class=\"quarto-layout-row quarto-layout-valign-top\">\n<div class=\"quarto-layout-cell\" style=\"flex-basis: 50.0%;justify-content: center;\">\n<p>La mémoire vive contient plusieurs milliards de circuits mémoires un bit, qui sont organisés en <em>cases mémoires</em> de huit, seize, trente-deux, soixante-quatre bits. Chaque case a une <em>adresse</em> unique, leur nombre détermine la capacité de la mémoire vive de l’ordinateur.</p>\n</div>\n<div class=\"quarto-layout-cell\" style=\"flex-basis: 50.0%;justify-content: center;\">\n<div class=\"quarto-figure quarto-figure-center\">\n<figure class=\"figure\">\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 411px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 61.48648648648649%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAC4jAAAuIwF4pT92AAABiElEQVR42q2SW27bMBBFteimf1lMV5E9BIj/AqSWZcutbZHWm29SIm8xsuEASRD4owNccEgODziPrDwcTV3XKMsy5fkam80GRVFgv99jvf697He7HdipAqsqMMaWdbvdYlMUyPOcYlLFGDjnKuu6DkIKNG0Lxjk4P4MxjnNd4+/hgBOB+BlCSkilIIRYxDlf7o6nE6qqQtf10Foj6/shKSUhhwBeTZitBTBfFd/9FJCih9ZqgaeUQGatRYwRIUwYR4lsGEZYp8Gef6F8eoR9/gn/8gC/eoB/+QG/uiisLme630OZgBjnT0Ap9QVojEJ3/IMqXyPwV6Tx7UvF4Q1GDVDK3H7onPsIHGC0QtvPaHvgGvelEcRoAynVDWiMuQGF0MjGcYS1BkYHeB+B9L2o3vTmVsOPwKYT8M5hmmbcY9SUUYhPTZmma8o0AnR4P1AvY/NNyhfgPP8PoEImpbwbSBAC0htK0Xu/+GEKcI5m1C5NcW6p4XQXkGLpAwRrmgZt05CfaG+tNf8Am1icTXeqk3AAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"vn mem\" title=\"\" src=\"/2022-2023/static/710d754abed7ccca48815c8a3bae2597/2a432/vn-mem.png\" srcset=\"/2022-2023/static/710d754abed7ccca48815c8a3bae2597/12f09/vn-mem.png 148w,\n/2022-2023/static/710d754abed7ccca48815c8a3bae2597/e4a3f/vn-mem.png 295w,\n/2022-2023/static/710d754abed7ccca48815c8a3bae2597/2a432/vn-mem.png 411w\" sizes=\"(max-width: 411px) 100vw, 411px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span></p>\n<p></p><figcaption class=\"figure-caption\">La mémoire est située à droite est séparée en deux parties: le programme et ses instructions à gauche(adresses 0 à 99) et les variables(adresses 100 et suivantes) avec leurs données à droite.</figcaption><p></p>\n</figure>\n</div>\n</div>\n</div>\n</div>\n<h3 id=\"lunité-de-commande-ri-et-cp\" class=\"anchored\">L’unité de commande (RI et CP)</h3>\n<div class=\"quarto-layout-panel\">\n<div class=\"quarto-layout-row quarto-layout-valign-top\">\n<div class=\"left quarto-layout-cell\" style=\"flex-basis: 50.0%;justify-content: center;\">\n<p>L’unité de commande contient <em>deux registres</em> pour stocker son état d’exécution:</p>\n<ul>\n<li>Le registre d’instruction (RI) stocke l’instruction du programme provenant de la mémoire programme actuellement exécutée.</li>\n<li>Le compteur de programme stocke la ligne du programme actuellement exécutée, après son exécution ce compteur est incrémenté de 1 (sauf en cas de saut: <code>JMP</code>).</li>\n</ul>\n</div>\n<div class=\"quarto-layout-cell\" style=\"flex-basis: 50.0%;justify-content: center;\">\n<div class=\"quarto-figure quarto-figure-center\">\n<figure class=\"figure\">\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 589px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 52.70270270270271%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAC4jAAAuIwF4pT92AAAB6klEQVR42oWSW0/bQBBG/f9/UZ8q8ViEBSSBhiQOvq7X9l59SUAITrV2KGofWktHu5r59vPO7ETrvGOdtcRHydWTZJO3rLIvQj6sN/uK+FBxvSu42ZXE+4qbfbmwKz/ipGZ9rPpoGjznsSfNMhKheJ16ht4R4mPv6J3BW40UJY0UiLKgLgvaWtDUAikq2rqiriqsVkTDMBDHMUopPj/vPW9vb7y/v6ONmbHWYd2FsLcWc8F5jxCCQ/IcDHtk25G3ltM00g8jWTMyTSOnacCHG35iDc5qnNO/Y86ZuaJaFCTJgcgYTasdD4Wm95ZOaa63jmNpyIUhry1ppdk8ZTwdBQ/7gtU2Zb1NOeQthXSzJq8dVWOITqcTWmvaTtMpxfl8Iqkst4nj/riwenb82Fq+3XruE8sqMVxtLN/Xnk3quDs67hLHz9QsJXfakEmFNYZ+WMoc/BdTH/poeUg9U295GS25dBxKx3kw88MFnTOKyGiN7PQ8HqFHSmm0Nn8QfiQaw+3BzY+nupZ9YXlM3eXMogsVRkEcDB8LNSfDi5q/sNYgW8NjPtDIGikFmezZFW6uJpgFnVoMNc1/DBexJkmOvL68EEZtnM74vp/7H/JhDaMUOWeXG+b/Ngw0TTPPaNcpnPOEsxezjyXe2V97ujWTGFbVTgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"vn uc\" title=\"\" src=\"/2022-2023/static/83fa334f2bdaf343e360f9674bb71107/b1665/vn-uc.png\" srcset=\"/2022-2023/static/83fa334f2bdaf343e360f9674bb71107/12f09/vn-uc.png 148w,\n/2022-2023/static/83fa334f2bdaf343e360f9674bb71107/e4a3f/vn-uc.png 295w,\n/2022-2023/static/83fa334f2bdaf343e360f9674bb71107/b1665/vn-uc.png 589w\" sizes=\"(max-width: 589px) 100vw, 589px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span></p>\n<p></p><figcaption class=\"figure-caption\">L’unité de commande possède deux registres: le registre d’instructions et le compteur de programme.</figcaption><p></p>\n</figure>\n</div>\n</div>\n</div>\n</div>\n<h3 id=\"lunité-arithmétique-et-logique-ual\" class=\"anchored\">L’unité arithmétique et logique (UAL)</h3>\n<div class=\"quarto-layout-panel\">\n<div class=\"quarto-layout-row quarto-layout-valign-top\">\n<div class=\"left quarto-layout-cell\" style=\"flex-basis: 50.0%;justify-content: center;\">\n<p>L’unité arithmétique et logique est composée de transistors assemblés de façon à lui permettre de réaliser un <em>petit nombre d’opérations simples (arithmétique: + -, logique booléenne: &amp; | !), mais à réaliser ces opérations très rapidement</em>.</p>\n<p>Le résultat des opérations est stocké dans un <em>registre</em> appelé accumulateur (ACC).</p>\n</div>\n<div class=\"quarto-layout-cell\" style=\"flex-basis: 50.0%;justify-content: center;\">\n<div class=\"quarto-figure quarto-figure-center\">\n<figure class=\"figure\">\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 400px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 61.48648648648649%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAC4jAAAuIwF4pT92AAAB3klEQVR42oWSz27TQBDG82aIC0/BqxSJM0cunEEqF8QTIG4VFWpKSqOqav45aho7+2/Wa++u7Sb+0G5wFLdIjPRJu+OZn2c+7UBK6YqigLUO3llkVIKMjefcGAghkGUZOOcgIlhboigt1qqEtTbK2RJMEn5OmRtorRG02+0Qom1bbLdbdMEYw2g0wiJZommamAu1XX2IuvJImcBlIjBQSkFKiTBlV5wskwM03PM8h3P+ANBESNNNPIefkFLIuMTFnO2BHbSqqljkK4+2PfRHaHuUCJC6aRAypDWUVEiZ6gODgkfH6/4vGu9QaAVnKPb/SngfGKY0xhwauqnCt/qvf92cqqxxcy9wuxK4exC4WnKcTZ5M2EG9971Jto+PvZWDH7NU4XzKcDHnUeczjsmDfA7sFPysa4+m9jDWR1/rukLT1DBFgZxkXNXme7mcYDQ9BxLtvZRSxTdolMBwvsF9JqDlBlJsIA/b9BVyAyllewwMEMY5BM9gf7+DvzzB+uwExfBNvJvxB5BIoUjjH3a18WF3ifDeFos5rq7HWK8SND9eo/r+CuOPL1B9ewkzfAsavYdmMygyUEr2gIEVVi6PoXsRSAmY6Ve4ySlW16dQt59R3n2CmXyBkiLWPIUF1h//aYvNkjDRbAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"vn ual\" title=\"\" src=\"/2022-2023/static/6dee27da71d64308e05545f9700ea98f/e17e5/vn-ual.png\" srcset=\"/2022-2023/static/6dee27da71d64308e05545f9700ea98f/12f09/vn-ual.png 148w,\n/2022-2023/static/6dee27da71d64308e05545f9700ea98f/e4a3f/vn-ual.png 295w,\n/2022-2023/static/6dee27da71d64308e05545f9700ea98f/e17e5/vn-ual.png 400w\" sizes=\"(max-width: 400px) 100vw, 400px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span></p>\n<p></p><figcaption class=\"figure-caption\">Le résultat des opérations des circuits calculatoires de l’UAL est stocké dans l’accumulateur pour l’exécution de calculs ultérieurs ou pour être renvoyé vers la mémoire.</figcaption><p></p>\n</figure>\n</div>\n</div>\n</div>\n</div>\n<h2 id=\"programmer-en-assembleur\" class=\"anchored\">Programmer en assembleur</h2>\n<p>Les cellules mémoire du programme sont stockées sous forme binaire, on les représente cependant sous forme textuelle. Un compilateur les convertit ensuite sous forme binaire pour les stocker dans la mémoire programme. Cette représentation textuelle est appelée le <em>langage assembleur</em>.</p>\n<p>Le jeu d’instructions de notre simulateur est résumé ci-dessous.</p>\n<table class=\"table table-bordered table-hover\">\n<thead class=\"table-warning\">\n<tr class=\"header\">\n<th colspan=\"3\"> Accès mémoire</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>LOAD var / LOAD #nb</code></td>\n<td>Transfère dans l’accumulateur la valeur de la variable <code>var</code> présente dans la mémoire ou directement le nombre <code>nb</code>.</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td><code>STORE var</code></td>\n<td>Transfère le contenu de l’accumulateur dans l’adresse mémoire associée à la variable <code>var</code>.<br>\n</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<details class=\"appli\"><summary>&nbsp;</summary>\n<p>Écrire un programme qui permet de stocker quatre valeurs 2, 3, 5, 7 dans les cases mémoires d’adresse 100(variable X), 101(Y), 102(Z), 103(W).</p>\n<p><em>Ne pas oublier d’ajouter l’instruction <code>HALT</code> en fin du programme pour arrêter l’incrémentation du CP.</em></p>\n<!--\n// Affectation des variables\nLOAD #2\nSTORE X\nLOAD #3\nSTORE Y\nLOAD #5\nSTORE Z\nLOAD #7\nSTORE W\nHALT\n-->\n</details>\n<table class=\"table table-bordered table-hover\">\n<thead class=\"table-warning\">\n<tr class=\"header\">\n<th colspan=\"2\"> Opérations arithmétiques</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>ADD var / ADD #nb</code></td>\n<td><em>Additionne</em> au contenu de l’accumulateur la valeur de la variable <code>var</code> de la mémoire ou directement le nombre <code>nb</code> et renvoie dans l’accumulateur le résultat.</td>\n</tr>\n<tr class=\"even\">\n<td><code>SUB var / SUB #nb</code></td>\n<td><em>Soustrait</em> au contenu de l’accumulateur la valeur de la variable <code>var</code> de la mémoire ou directement le nombre <code>nb</code> et renvoie dans l’accumulateur le résultat.</td>\n</tr>\n</tbody>\n</table>\n<details class=\"appli\"><summary>&nbsp;</summary>\n<p>Compléter le programme de l’application précédente pour additionner les quatre nombres contenus dans les cases mémoires X, Y, Z et W et de stocker le résultat de cette addition dans la case mémoire 104(N).</p>\n<!-- \n// Addition\nLOAD X\nADD Y\nADD Z\nADD W\nSTORE N\nHALT\n-->\n</details>\n<table class=\"table table-bordered table-hover\">\n<thead class=\"table-warning\">\n<tr class=\"header\">\n<th colspan=\"3\"> Opération logique</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>CMP adr / CMP #nb</code></td>\n<td>Compare le contenu de l’accumulateur à la valeur de la variable <code>var</code> de la mémoire ou au nombre <code>nb</code> et renvoie dans l’accumulateur le résultat -1,0 ou 1 selon le résultat de la comparaison: inférieur, égal ou supérieur.</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<details class=\"appli\"><summary>&nbsp;</summary>\n<p>Compléter le programme de l’application précédente pour comparer le contenu des cases mémoires X et N et de stocker le résultat de cette comparaison dans la case mémoire 6(R).</p>\n<!-- \n// Comparaison\nLOAD X\nCMP N\nSTORE R\nHALT\n-->\n</details>\n<div class=\"callout callout-style-default callout-tip callout-captioned\">\n<div class=\"callout-header d-flex align-content-center\">\n<div class=\"callout-icon-container\">\n<i class=\"callout-icon\"></i>\n</div>\n<div class=\"callout-caption-container flex-fill\">\nAjouter des étiquettes aux lignes du programme\n</div>\n</div>\n<div class=\"callout-body-container callout-body\">\n<p>Pour pouvoir réaliser des boucles ou sauter des lignes en fonction de conditions, on utilise des instructions de saut <code>JMP</code> qui permettront de se déplacer vers une ligne spécifique du programme ou vers une ligne précédée d’une étiquette <code>inf: LOAD X</code> ici l’étiquette est <code>inf</code> on peut s’y rendre avec <code>JMP inf</code>.</p>\n</div>\n</div>\n<table class=\"table table-bordered table-hover\">\n<thead class=\"table-warning\">\n<tr class=\"header\">\n<th colspan=\"3\"> Contrôle du programme: Conditions, boucles, commentaires…</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>JMP étiquette / JMP n</code></td>\n<td>Transfère dans le compteur de programme <em>CP</em> le numéro de ligne <code>n</code> ou le numéro de la ligne avec l’étiquette <code>étiquette</code>.</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td><code>JMPZ étiquette / JMPZ n</code></td>\n<td>Transfère <strong>uniquement si le contenu de l’accumulateur est nul</strong> dans le compteur de programme <em>CP</em> le numéro de ligne <code>n</code> ou le numéro de la ligne avec l’étiquette <code>étiquette</code>.</td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td><code>JMPN étiquette / JMPN n</code></td>\n<td>Transfère <strong>uniquement si le contenu de l’accumulateur est négatif</strong> dans le compteur de programme <em>CP</em> le numéro de ligne <code>n</code> ou le numéro de la ligne avec l’étiquette <code>étiquette</code>.</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td><code>JMPP étiquette / JMPP n</code></td>\n<td>Transfère <strong>uniquement si le contenu de l’accumulateur est positif</strong> dans le compteur de programme <em>CP</em> le numéro de ligne <code>n</code> ou le numéro de la ligne avec l’étiquette <code>étiquette</code>.</td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td><code>HALT</code></td>\n<td>Stoppe l’exécution du programme.</td>\n<td></td>\n</tr>\n<tr class=\"even\">\n<td><code>// commentaire</code></td>\n<td>Ligne de commentaire non exécutée.</td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td><code>INSTRUCTION X ; commentaire de ligne</code></td>\n<td>On peut ajouter des commentaires de lignes avec un point virgule.</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<details class=\"appli\"><summary>Multiplication d'entiers positifs</summary>\n<p>Stocker deux entiers positifs quelconques dans les variables <code>X</code> et <code>Y</code>, puis sans utiliser l’opérateur <code>MUL</code>, réaliser l’opération <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>×</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X\\times Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>\net stocker le résultat dans la case mémoire 105(variable R).</p>\n<p>Pour cela on initialisera une variable <code>R</code> à 0 à laquelle on ajoutera <code>X</code> <code>Y</code> fois grâce à une boucle. A chaque tour de boucle, ajouter <code>X</code> à <code>R</code>, soustraire 1 à <code>Y</code> tant que <code>Y</code> est positif grâce à un <code>JMPP</code>.</p>\n<!-- \n// X x Y sans MUL\n<p>// initialisation variables\n// X = 4\nLOAD #4\nSTO X\n// Y = 5\nLOAD #5\nSTO Y\n// R = 0\nLOAD #0\nSTO R</p>\n<p>// boucle\nboucle: LOAD R\n// R = R + Y\nADD Y\nSTO R\n// X = X-1\nLOAD X\nSUB #1\nSTO X\n// boucle tant que X > 0\nJMPP boucle\nHALT\n--></p>\n</details>\n<details class=\"appli\"><summary>Multiplication d'entiers quelconques</summary>\n<p>Adapter l’algorithme précédent grâce à une condition:</p>\n<ul>\n<li>Si <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">Y &gt; 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>\n: reprendre l’algorithme précédent.</li>\n<li>Si <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">Y &lt; 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>\n: soustraire <code>X</code> <code>Y</code> fois grâce à une boucle.</li>\n<li>Si <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">Y = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>\n: terminer le programme et laisser <code>R</code> à 0.</li>\n</ul>\n<!-- \n// initialisation variables\n// X = 4\nLOAD #-4\nSTO X\n// Y = 5\nLOAD #-5\nSTO Y\n<p>// R = 0\nLOAD #0\nSTO R</p>\n<p>// Condition sur X\nLOAD X\n// X > 0\nJMPP boucle\n// X &#x3C; 0\nJMPN boucleneg\n// X = 0\nJMPZ fin</p>\n<p>// boucle X > 0\nboucle: LOAD R\n// R = R + Y\nLOAD R\nADD Y\nSTO R\n// X = X-1\nLOAD X\nSUB #1\nSTO X\n// boucle tant que X > 0\nJMPP boucle\nJMPZ fin</p>\n<p>// boucle X &#x3C; 0\nboucleneg: LOAD R\n// R = R + Y\nLOAD R\nSUB Y\nSTO R\n// X = X + 1\nLOAD X\nADD #1\nSTO X\n// boucle tant que X > 0\nJMPN boucleneg</p>\n<p>fin: HALT\n--></p>\n</details>\n<div class=\"ref\">\n<ul>\n<li><p>Chapitre 1: Au cœur de l’ordinateur <a href=\"https://www.enseignants.hachette-education.com/livres/numerique-sciences-informatiques-1re-specialite-livre-eleve-ed-2021-9782017866305\">NSI Première Hachette 2021 sous la direction de Michel Beaudouin-Lafon</a></p></li>\n<li><p>Chapitre 15: L’organisation d’un ordinateur <a href=\"http://www.editions-eyrolles.com/Livre/9782212135435/\">Informatique et sciences du numérique Spécialité ISN en terminale S - Avec des exercices corrigés et des idées de projets par Gilles Dowek</a></p></li>\n</ul>\n</div>","tableOfContents":"","frontmatter":{"tags":["langage machine","assembleur","jeu d'instructions"],"tocHTML":"<ul><li><a href=\"#les-divers-éléments-de-la-simulation\" data-localhref=\"true\">Les divers éléments de la simulation</a></li><ul><li><a href=\"#la-mémoire-ram\" data-localhref=\"true\">La mémoire (RAM)</a></li><li><a href=\"#lunité-de-commande-ri-et-cp\" data-localhref=\"true\">L’unité de commande (RI et CP)</a></li><li><a href=\"#lunité-arithmétique-et-logique-ual\" data-localhref=\"true\">L’unité arithmétique et logique (UAL)</a></li></ul><li><a href=\"#programmer-en-assembleur\" data-localhref=\"true\">Programmer en assembleur</a></li></ul>"},"fields":{"classe":"1g","chapter":"Jeu d’instructions du processeur","matter":"nsi","nChapter":"2","part":"Architectures matérielles et systèmes d’exploitation","nPart":"6"}}},"pageContext":{"slug":"1g/nsi/6-architectures-materielles-et-systemes-dexploitation/2-jeu-dinstructions-du-processeur","chapter":"Jeu d’instructions du processeur"}},"staticQueryHashes":["604483588"],"slicesMap":{}}