{"componentChunkName":"component---src-templates-exo-md-js","path":"/tg/nsi/5-algorithmique/1-algorithmes-sur-les-arbres-binaires/exo/","result":{"data":{"markdownRemark":{"html":"<h2 id=\"implémentations-des-algorithmes-du-cours\" class=\"anchored\">Implémentations des algorithmes du cours</h2>\n<p>En utilisant le module <a href=\"https://github.com/joowani/binarytree\"><code>binarytree</code></a>, implémenter les algorithmes du programme officiel:</p>\n<ul>\n<li><p>Calculer la hauteur de l’arbre</p></li>\n<li><p>Calculer la taille de l’arbre</p></li>\n<li><p>Parcours de l’arbre</p>\n<ul>\n<li>Parcours préfixe</li>\n<li>Parcours postfixe</li>\n<li>Parcours infixe</li>\n<li>Parcours en largeur</li>\n</ul></li>\n<li><p>Arbre binaire de recherche</p>\n<ul>\n<li>Insertion d’une clé</li>\n<li>Recherche d’une clé</li>\n</ul></li>\n</ul>\n<p>Pour le parcours en largeur, on pourra utiliser la classe <code>File</code> suivante.</p>\n<div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">collections</span> <span class=\"kn\">import</span> <span class=\"n\">deque</span>\n<span></span>\n<span class=\"k\">class</span> <span class=\"nc\">File</span><span class=\"p\">:</span>\n<span class=\"c1\">    # pas d'initialisation si on crée tjs des files vides</span>\n<span class=\"n\">    _data</span> <span class=\"o\">=</span> <span class=\"n\">deque</span><span class=\"p\">()</span>\n<span class=\"k\">    \n    def</span> <span class=\"nf\">enfiler</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">élément</span><span class=\"p\">):</span>\n<span class=\"bp\">        self</span><span class=\"o\">.</span><span class=\"n\">_data</span><span class=\"o\">.</span><span class=\"n\">appendleft</span><span class=\"p\">(</span><span class=\"n\">élément</span><span class=\"p\">)</span>\n<span class=\"k\">    \n    def</span> <span class=\"nf\">défiler</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"k\">        return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_data</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">()</span>\n<span class=\"k\">    \n    def</span> <span class=\"nf\">est_vide</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"k\">        return</span> <span class=\"ow\">not</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_data</span>\n<span></span>\n<span class=\"k\">    def</span> <span class=\"nf\">tête</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"k\">        return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_data</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n</pre></div>\n<h2 id=\"version-itérative-des-parcours-en-profondeur\" class=\"anchored\">Version itérative des parcours en profondeur</h2>\n<p>Il est possible d’écrire des versions iteratives (et non récursive) des algorithmes de parcours en profondeur.</p>\n<p>Pour cela on utilisera une pile(<em>stack</em> en anglais).</p>\n<p>Voici les pseudo-codes proposés sur l’article <a href=\"https://en.wikipedia.org/wiki/Tree_traversal#Implementations\">Wikipédia en anglais</a>.</p>\n<h3 id=\"parcours-préfixe-itératif\" class=\"anchored\">Parcours préfixe itératif</h3>\n<div class=\"highlight\"><pre><span></span>iterativePreorder(node)\n  if (node == null)\n    return\n  s ← empty stack\n  s.push(node)\n  while (not s.isEmpty())\n    node ← s.pop()\n    visit(node)\n    //right child is pushed first so that left is processed first\n    if node.right ≠ null\n      s.push(node.right)\n    if node.left ≠ null\n      s.push(node.left)\n</pre></div>\n<h3 id=\"parcours-infixe-itératif\" class=\"anchored\">Parcours infixe itératif</h3>\n<div class=\"highlight\"><pre><span></span>iterativeInorder(node)\n  s ← empty stack\n  while (not s.isEmpty() or node ≠ null)\n    if (node ≠ null)\n      s.push(node)\n      node ← node.left\n    else\n      node ← s.pop()\n      visit(node)\n      node ← node.right\n</pre></div>\n<h3 id=\"parcours-postfixe-itératif\" class=\"anchored\">Parcours postfixe itératif</h3>\n<div class=\"highlight\"><pre><span></span>iterativePostorder(node)\n  s ← empty stack\n  lastNodeVisited ← null\n  while (not s.isEmpty() or node ≠ null)\n    if (node ≠ null)\n      s.push(node)\n      node ← node.left\n    else\n      peekNode ← s.peek()\n      // if right child exists and traversing node\n      // from left child, then move right\n      if (peekNode.right ≠ null and lastNodeVisited ≠ peekNode.right)\n        node ← peekNode.right\n      else\n        visit(peekNode)\n        lastNodeVisited ← s.pop()\n</pre></div>\n<p>Pour faire cet exercice, on pourra utiliser la classe <code>Pile</code> suivante.</p>\n<div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Pile</span><span class=\"p\">:</span>\n<span class=\"k\">    def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"c1\">        # Initialisation par une liste vide</span>\n<span class=\"bp\">        self</span><span class=\"o\">.</span><span class=\"n\">_data</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n<span class=\"k\">    \n    def</span> <span class=\"nf\">empiler</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">élément</span><span class=\"p\">):</span>\n<span class=\"bp\">        self</span><span class=\"o\">.</span><span class=\"n\">_data</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">élément</span><span class=\"p\">)</span>\n<span class=\"k\">    \n    def</span> <span class=\"nf\">dépiler</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"k\">        return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_data</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">()</span>\n<span class=\"k\">    \n    def</span> <span class=\"nf\">est_vide</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"k\">        return</span> <span class=\"ow\">not</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_data</span>\n<span></span>\n<span class=\"k\">    def</span> <span class=\"nf\">sommet</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"k\">        return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_data</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n</pre></div>\n<h2 id=\"un-arbre-de-compétition-daprès-bac-2021\" class=\"anchored\">Un arbre de compétition <em>(d’après BAC 2021)</em></h2>\n<!-- Amérique du Nord 2021 Ex4 -->\n<p>La fédération de badminton souhaite gérer ses compétitions à l’aide d’un logiciel. Pour ce faire, une structure <code>arbre de compétition</code> a été définie récursivement de la façon suivante: un arbre de compétition est soit l’arbre vide, noté ∅, soit un triplet composé d’une chaîne de caractères appelée valeur, d’un arbre de compétition appelé sous-arbre gauche et d’un arbre de compétition appelé sous-arbre droit.</p>\n<ol type=\"1\">\n<li>On considère l’arbre de compétition <code>B</code> suivant:</li>\n</ol>\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 573px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 38.513513513513516%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAA9UlEQVR42m2Q2Y6FIAyGff+HdMUFF8QWkEXKZGRiPJPzXTRN279bkV4Q0WMBYF1X59yTyrzri/QJEVlrAUBrjYjZf7f4L84hY8y+7+d5ImII4akIISCivFFKfZlMRFJKzrnWOn1DCME5X9f1QxxC8N5LKY0xKSUppRAihBBjTCn5G7hJKSGiECLGmFf7Fbdtu+97bhZjbJpmHMdnZ8ZY13XXdeXsMAxN0/yJrbVKKUS8rivG6JxTSgFAHu69R0QA8N4TUb4/v5CIirIsEZFzPs/ztm1lWS7Lwhjr+36e56qqxnGcpokxtm1bXdecc8ZY27bHcfwAZbvOu7GFAjgAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"ex4 5\" title=\"\" src=\"/2022-2023/static/6fe85d9f604f1108e5c085151adbb177/3c024/ex4-5.png\" srcset=\"/2022-2023/static/6fe85d9f604f1108e5c085151adbb177/12f09/ex4-5.png 148w,\n/2022-2023/static/6fe85d9f604f1108e5c085151adbb177/e4a3f/ex4-5.png 295w,\n/2022-2023/static/6fe85d9f604f1108e5c085151adbb177/3c024/ex4-5.png 573w\" sizes=\"(max-width: 573px) 100vw, 573px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span></p>\n<p>Créer l’arbre de compétition <code>B</code> à l’aide de la classe <code>ArbreBinaire</code> vue dans le <a href=\"/tg/nsi/1-structures-de-donnees/4-arbres\">chapitre P1C4</a>.</p>\n<ol start=\"2\" type=\"1\">\n<li><p>Écrire les fonctions suivantes:</p>\n<ul>\n<li>La fonction <code>racine</code> qui prend en paramètre un arbre de compétition <code>arb</code> et renvoie la valeur de la racine.</li>\n</ul></li>\n</ol>\n<p>Exemple: en reprenant l’exemple d’arbre de compétition présenté ci-dessus, <code>racine(B)</code> vaut <code>\"Lea\"</code>.</p>\n<ul>\n<li><p>La fonction <code>gauche</code> qui prend en paramètre un arbre de compétition <code>arb</code> et renvoie son sous-arbre gauche.</p></li>\n<li><p>La fonction <code>droit</code> qui prend en argument un arbre de compétition <code>arb</code> et renvoie son sous-arbre droit.</p></li>\n<li><p>La fonction <code>est_vide</code> qui prend en argument un arbre de compétition et renvoie <code>True</code> si l’arbre est vide et <code>False</code> sinon.</p>\n<p>Exemple:en reprenant l’exemple d’arbre de compétition présenté ci-dessus, <code>est_vide(B)</code> vaut <code>False</code>.</p></li>\n</ul>\n<p>** Dans toute la suite de l’exercice, vous ne devrez utiliser que les fonctions définies dans les questions précédent la question posée.**</p>\n<ol start=\"3\" type=\"1\">\n<li><p>&nbsp;</p>\n<ol type=\"1\">\n<li><p>Proposer une fonction Python <code>occurrences</code> ayant pour paramètre un arbre de compétition <code>arb</code> et le nom d’un joueur <code>nom</code> et qui renvoie le nombre d’occurrences (d’apparitions) du joueur <code>nom</code> dans l’arbre de compétition <code>arb</code>.</p>\n<p>Exemple: <code>occurences(B,\"Anne\")</code> vaut <code>2</code>.</p></li>\n<li><p>Proposer une fonction Python <code>a_gagne</code> prenant pour paramètres un arbre de compétition <code>arb</code> et le nom d’un joueur <code>nom</code> et qui renvoie le booléen <code>True</code> si le joueur <code>nom</code> a gagné au moins un match dans la compétition représenté par l’arbre de compétition <code>arb</code>.</p>\n<p>Exemple: <code>a_gagne(B,\"Louis\")</code> vaut True</p></li>\n</ol></li>\n<li><p>On souhaite programmer une fonction Python <code>nombre_matchs</code> qui prend pour arguments un arbre de compétition <code>arb</code> et le nom d’un joueur <code>nom</code> et qui renvoie le nombre de matchs joués par le joueur <code>nom</code> dans la compétition représentée par l’arbre de compétition <code>arb</code></p>\n<p>Exemple: <code>nombre_matchs(B,\"Lea\")</code> doit valoir <code>3</code> et <code>nombre_matchs(B,\"Marc\")</code> doit valoir <code>1</code>.</p>\n<ol type=\"1\">\n<li><p>Expliquer pourquoi les instructions suivantes renvoient une valeur erronée. On pourra pour cela identifier le nœud de l’arbre qui provoque une erreur.</p>\n<div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">nombre_matchs</span><span class=\"p\">(</span><span class=\"n\">arb</span> <span class=\"p\">,</span><span class=\"n\">nom</span><span class=\"p\">):</span>\n<span class=\"w\">    </span><span class=\"sd\">\"\"\"arbre_competition , str -&gt; int\"\"\"</span>\n<span class=\"k\">    return</span> <span class=\"n\">occurrences</span><span class=\"p\">(</span><span class=\"n\">arb</span><span class=\"p\">,</span> <span class=\"n\">nom</span><span class=\"p\">)</span>\n</pre></div>\n</li>\n<li><p>Proposer une correction pour la fonction <code>nombre_matchs</code>.</p></li>\n</ol></li>\n<li><p>Recopier et compléter la fonction <code>liste_joueurs</code> qui prend pour argument un arbre de compétition <code>arb</code> et qui renvoie un tableau contenant les participants au tournoi, chaque nom ne devant figurer qu’une seule fois dans le tableau.</p>\n<p>L’opération <code>+</code> à la ligne 8 permet de concaténer deux tableaux.</p>\n<p>Exemple: Si <code>L1 = [4, 6, 2]</code> et <code>L2 = [3 ,5 ,1 ]</code>, l’instruction <code>L1 + L2</code> va renvoyer le tableau <code>[4, 6, 2, 3, 5, 1]</code></p></li></ol>\n<div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">liste_joueurs</span><span class=\"p\">(</span><span class=\"n\">arb</span><span class=\"p\">):</span>\n<span class=\"w\">    </span><span class=\"sd\">\"\"\"arbre_competition -&gt; tableau\"\"\"</span>\n<span class=\"k\">    if</span> <span class=\"n\">est_vide</span><span class=\"p\">(</span><span class=\"n\">arb</span><span class=\"p\">):</span>\n<span class=\"k\">         return</span> <span class=\"o\">...</span>\n<span class=\"k\">     elif</span> <span class=\"o\">...</span> <span class=\"ow\">and</span> <span class=\"o\">...</span> <span class=\"p\">:</span>\n<span class=\"k\">         return</span> <span class=\"p\">[</span><span class=\"n\">racine</span><span class=\"p\">(</span><span class=\"n\">arb</span><span class=\"p\">)]</span>\n<span class=\"k\">     else</span><span class=\"p\">:</span>\n<span class=\"k\">         return</span> <span class=\"o\">...</span> <span class=\"o\">+</span> <span class=\"n\">liste_joueurs</span><span class=\"p\">(</span><span class=\"n\">droit</span><span class=\"p\">(</span><span class=\"n\">arb</span><span class=\"p\">))</span>\n</pre></div>\n</li>\n</ol>","frontmatter":{"tocHTML":"<ul><li><a href=\"#implémentations-des-algorithmes-du-cours\" data-localhref=\"true\">Implémentations des algorithmes du cours</a></li><li><a href=\"#version-itérative-des-parcours-en-profondeur\" data-localhref=\"true\">Version itérative des parcours en profondeur</a></li><ul><li><a href=\"#parcours-préfixe-itératif\" data-localhref=\"true\">Parcours préfixe itératif</a></li><li><a href=\"#parcours-infixe-itératif\" data-localhref=\"true\">Parcours infixe itératif</a></li><li><a href=\"#parcours-postfixe-itératif\" data-localhref=\"true\">Parcours postfixe itératif</a></li></ul><li><a href=\"#un-arbre-de-compétition-daprès-bac-2021\" data-localhref=\"true\">Un arbre de compétition <em>(d’après BAC 2021)</em></a></li></ul>"},"fields":{"classe":"tg","chapter":"Algorithmes sur les arbres binaires","matter":"nsi","nChapter":"1","part":"Algorithmique","nPart":"5","type":"exo"}}},"pageContext":{"slug":"tg/nsi/5-algorithmique/1-algorithmes-sur-les-arbres-binaires/exo"}},"staticQueryHashes":["604483588"],"slicesMap":{}}