{"componentChunkName":"component---src-templates-cours-md-js","path":"/tg/nsi/5-algorithmique/4-programmation-dynamique/","result":{"data":{"markdownRemark":{"html":"<p><strong>Ce chapitre ne pourra pas faire l’objet d’une évaluation lors de l’épreuve terminale écrite et pratique de l’enseignement de spécialité.</strong> <a href=\"https://www.education.gouv.fr/bo/21/Hebdo30/MENE2121274N.htm\" class=\"cite-source\">BO MENE2121274N</a></p>\n<details class=\"programme\"><summary>Programme Officiel</summary>\n<table class=\"table table-bordered table-hover\">\n<thead class=\"table-warning\">\n<tr class=\"header\">\n<th>Contenus</th>\n<th>Capacités attendues</th>\n<th>Commentaires</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>Programmation dynamique.</td>\n<td>Utiliser la programmation dynamique pour écrire un algorithme.</td>\n<td><p>Les exemples de l’alignement de séquences ou du rendu de monnaie peuvent être présentés.</p>\n<p>La discussion sur le coût en mémoire peut être développée.</p></td>\n</tr>\n</tbody>\n</table>\n<a class=\"lien-programme\" href=\"../programme/\">Lien vers le programme complet</a></details>\n<!-- \n\n> Dans ce chapitre, nous allons étudier la _programmation dynamique_, c'est une technique qui comme\n> la méthode \"diviser pour régner décompose un problème en plus petits problèmes plus faciles à\n> résoudre. Cependant, elle y ajoute la technique de _mémoïsation_ qui permet d'éviter d'effectuer\n> plusieurs fois le même calcul lorsque les sous-problèmes ne sont pas indépendants.\n\n## Principe\n\nNous allons illustrer le principe de la programmation dynamique sur le calcul de la suite de\nFibonacci. La suite de Fibonacci est une suite d'entiers dans laquelle chaque terme est la somme\ndes deux termes qui le précèdent. \n\n$$\n{\\mathcal {F}}_{0} = 0 , \\quad {\\mathcal {F}}_{1}=1, et\n{\\mathcal {F}}_{n} = {\\mathcal {F}}_{n-1} + {\\mathcal {F}}_{n-2}\n$$\n\n::: plus\n\nCette suite est liée au nombre d'or, ou proportion divine telle que:\n\n$$\n\\frac{a+b}{a} = \\frac{a}{b}\n$$\n\n:::\n\nSi on appliquait simplement la méthode \"diviser pour régner\", l'algorithme s'écrirait:\n\n```\nFONCTION fibonacci(n)\n   SI n = 0 OU n = 1\n         RETOURNER n\n   SINON\n         RETOURNER fibonacci(n-1) + fibonacci(n-2)\n```\nCependant cette méthode n'est pas du tout efficace, pour calculer ${\\mathcal {F}}_{5}$, je dois\ncalculer deux fois ${\\mathcal {F}}_{3}$, comme le montre le graph de dépendances des sous problème.\n\n<p><a href=\"https://commons.wikimedia.org/wiki/File:Fibonacci_dynamic_programming.svg#/media/Fichier:Fibonacci_dynamic_programming.svg\"><img width=\"128px\" src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/0/06/Fibonacci_dynamic_programming.svg/1200px-Fibonacci_dynamic_programming.svg.png\" alt=\"Fibonacci dynamic programming.svg\"></a><br>Image par <a href=\"https://en.wikipedia.org/wiki/User:Dcoatzee\" class=\"extiw\" title=\"en:User:Dcoatzee\">en:User:Dcoatzee</a>, traced by <a href=\"//commons.wikimedia.org/wiki/User:Stannered\" title=\"User:Stannered\">User:Stannered</a> — <a href=\"https://en.wikipedia.org/wiki/Image:Fibonacci_dynamic_programming.png\" class=\"extiw\" title=\"en:Image:Fibonacci dynamic programming.png\">en:Image:Fibonacci dynamic programming.png</a>, Domaine public, <a href=\"https://commons.wikimedia.org/w/index.php?curid=3325402\">Lien</a></p>\n\nCe graph n'est pas un arbre ce qui illustre que les _sous-problèmes se chevauchent_. Dès que n\ndevient un peu plus grand, ces calculs inutiles à répétition rendent l'algorithme inutilisable.\n\nNous allons utiliser la technique de _mémoïsation_ de la programmation dynamique pour stocker les\nrésultats intermédiaires et les utiliser pour éviter les calculs identiques.\n\n```\nF = []  # Cette liste est utilisée pour stocker les termes de la suite au fur et à mesure\nFONCTION fibonacci(n)\n   SI F[n] n'est pas défini\n      SI n = 0 ou n = 1\n         F[n] := n\n      SINON\n         F[n] := fibonacci(n-1) + fibonacci(n-2)\n   retourner F[n]\n```\n\n::: {.plus titre=\"Implémentation en Python\"}\n\nEn mesurant les temps respectifs avec `timeit`, on constate que qu'avec des nombres de quelques\ndizaines seulement, l'algorithme dynamique est déjà 3000 fois plus rapide, et l'écart s'accentue\nplus n est grand.\n\n```python\n%%timeit\ndef fibonacci(n):\n    if n == 0 or n == 1:\n        return n\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n\nassert fibonacci(13) == 233\nassert fibonacci(25) == 75025\n```\n\n`19.7 ms ± 5.79 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)`\n\n```python\n%%timeit\nF = [0, 1]\ndef fibonacci_dynamique(n):\n    if n < 2:\n        return n\n    elif n < len(F):\n        return F[n]    \n    else:\n        fn = fibonacci_dynamique(n-1) + fibonacci_dynamique(n-2)\n        F.append(fn)\n    return F[n]\nassert fibonacci_dynamique(13) == 233\nassert fibonacci_dynamique(25) == 75025\n```\n\n`6.35 µs ± 11.3 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)`\n\n:::\n\nBien sûr l'utilisation de la liste a un coût mémoire, le gain temporel(la complexité temporelle) se\nfait au détriment de l'utilisation de la mémoire(On parle de complexité spatiale en ce qui concerne\nla mémoire).\n\n\n\n## Le problème du sac à dos\n\nNous avions déjà vu le problème en première dans le chapitre sur les [algorithmes\ngloutons](../../../1g/nsi/8-algorithmique/5-algorithmes-gloutons/) qui nous avait permis\nd'obtenir une solution assez bonne mais pas forcément optimale par la méthode gloutonne.\n\n<p><a href=\"https://commons.wikimedia.org/wiki/File:Knapsack.svg#/media/File:Knapsack.svg\"><img width=\"256px\" src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/f/fd/Knapsack.svg/1200px-Knapsack.svg.png\" alt=\"Knapsack.svg\"></a><br><a href=\"https://creativecommons.org/licenses/by-sa/2.5\" title=\"Creative Commons Attribution-Share Alike 2.5\">CC BY-SA 2.5</a>, <a href=\"https://commons.wikimedia.org/w/index.php?curid=985491\">Link</a></p>\n\nC'est un problème d'optimisation sous contrainte: Comment maximiser la valeur contenue dans le sac\nsans dépasser la capacité du sac?\n\n\nNous allons appliquer à ce problème la programmation dynamique car il possède une propriété\nparticulière:\n\n> Le problème du sac à dos possède la propriété de sous-structure optimale, c'est-à-dire que l'on\n> peut construire la solution optimale du problème à $i$ variables à partir du problème à $i-1$\n> variables.\n\n[Article Wikipedia sur le problème du sac à dos](https://fr.wikipedia.org/wiki/Probl%C3%A8me_du_sac_%C3%A0_dos#Programmation_dynamique){.cite-source}\n\nEn clair il est possible de trouver la solution pour un sac de capacité $W$ si on connait la\nsolution pour tous les sacs de capacité inférieur à $W$.\n\nOn va construire un tableau avec nos solutions optimales pour les sacs allant de 1 à 15kg.\n\nPour chaque masse de sac $m$, on a pour chaque objet deux possibilités:\n\n- On prend cet objet de masse $m_i$ et de valeur $v_{i}$.\n- On ne prend pas cet objet.\n\nPour prendre cette décision, il suffit de comparer la valeur du sac si on ne prend pas l'objet à la\nvaleur du sac si on prend cet objet **plus** la plus grande valeur du sac de poids capacité du sac\nmoins masse de l'objet, la solution gardée est:\n\n$$\n\\max \\left(valeur(m - m_i) + v_{i} \\right)\n$$\n\n_Ne pas prendre l'objet consiste à prendre un objet de masse nulle et de valeur nulle(voir\nimplémentation)._\n\n::: {.plus titre=\"Implémentation en Python\"}\n\n```python\n# adapté de https://dev.to/downey/solving-the-knapsack-problem-with-dynamic-programming-4hce\n\n# | objet | masse | valeur |\n# |-------|-------|--------|\n# | 1     | 1     | 1      |\n# | 2     | 1     | 2      |\n# | 3     | 2     | 2      |\n# | 4     | 4     | 10     |\n# | 5     | 12    | 4      |\n\n# On a ajouté l'absence d'objet avec les 0\nobjet_masses = [0, 1, 1, 2, 4, 12]\nobjet_valeurs = [0, 1, 2, 2, 10, 4]\n\nn = len(objet_masses)\nMASSE_MAX = 15  # Capacité maximale du sac\n\n# initialisation de notre liste de valeurs optimales à 0\nsac_optimisés = [0 for i in range(MASSE_MAX + 1)]\n\n# Itération sur toutes les masses de 1 à 15kg\n# (Approche BOTTOM-UP nécessaire à la mémoïsation)\nfor m in range(1, MASSE_MAX + 1):\n    valeur_max_pour_m = 0\n    for i in range(1, n):\n        mi = objet_masses[i]\n        vi = objet_valeurs[i]\n        if mi <= m:\n            valeur_avec_objet_i = sac_optimisés[m - mi] + vi\n            if valeur_avec_objet_i > valeur_max_pour_m:\n                valeur_max_pour_m = valeur_avec_objet_i\n    sac_optimisés[m] = valeur_max_pour_m\n\n# Results\nprint(\"Resultat: \", sac_optimisés[MASSE_MAX])\nprint(\"liste des sac_optimisés: \", sac_optimisés)\n```\nLa démonstration de la correction de l'algorithme est donnée [ici](eind).\n\nLa complexité est $O(mn)$, puisqu'on fait une itération de tous les objets pour tous les sacs(Force\nBrute).\n\n:::\n\n\nOn obtient ce tableau qui permet de voir que la solution optimale est 36€ pour un sac de 15kg.\n\n| Capacité du sac(kg) | 0 | 1 | 2 | 3 | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 | 12 | 13 | 14 | 15 |\n|---------------------|---|---|---|---|----|----|----|----|----|----|----|----|----|----|----|----|\n| Valeur maximale(€)  | 0 | 2 | 4 | 6 | 10 | 12 | 14 | 16 | 20 | 22 | 24 | 26 | 30 | 32 | 34 | 36 |\n\nComme vous le voyez cet algorithme nous donne la valeur maximale du sac, mais on ne sait pas quels\nobjets, il faut prendre, on va le modifier pour garder en plus de la valeur maximale les objets\npris.\n\nNous allons modifier légérement le code pour garder un trace des sacs optimaux réalisés en\nmodifiant légérement la liste utilisée pour la mémoïsation:\n\nAu lieu de stocker simplement la valeur du sac, on crée une liste avec:\n\n- la valeur à l'index 0 \n- le contenu du sac à l'index 1 sous forme de liste\n\nLe meilleur sac de 14 kg `[14, [0, 0, 2, 0, 1, 0]]` a une valeur de 14€ avec 2 objets de 2kg à 2€\net 1 objet de 4kg à 10€.\n\n::: {.plus titre=\"Implémentation en Python\"}\n\n```python\n# Pour connaitre le jeu d'objets de la solution optimale\n# On va stocker les objets dans une liste \n# en plus de la valeur maximale du sac\n\n# On a ajouté l'absence d'objet avec les 0\nobjet_masses = [0, 1, 1, 2, 4, 12]\nobjet_valeurs = [0, 1, 2, 2, 10, 4]\n\nn = len(objet_masses)\nMASSE_MAX = 15  # Capacité maximale du sac\n\n\ndef pas_dobjets():\n    \"\"\"renvoie une liste vide contenant les objets choisis\n    \n    Fonction utilitaire car les listes sont passées en références\"\"\"\n    return [0 for i in range(n)]\n\n# initialisation de notre liste de valeurs optimales\nsac_optimisés = [[0, pas_dobjets()] for i in range(MASSE_MAX + 1)]\n\n# Itération sur toutes les masses de 1 à 15kg\n# (Approche BOTTOM-UP nécessaire à la mémoïsation)\nfor m in range(1, MASSE_MAX + 1):\n    # On crée une sous liste pour la liste des objets\n    valeur_max_pour_m = [0, pas_dobjets()]\n    for i in range(1, n):\n        mi = objet_masses[i]\n        vi = objet_valeurs[i]\n        if mi <= m:\n            valeur_avec_objet_i = sac_optimisés[m - mi][0] + vi\n            if valeur_avec_objet_i > valeur_max_pour_m[0]:\n                valeur_max_pour_m[0] = valeur_avec_objet_i\n                valeur_max_pour_m[1] = sac_optimisés[m - mi][1].copy()\n                valeur_max_pour_m[1][i] += 1\n    sac_optimisés[m] = valeur_max_pour_m\n\n# Results\nprint(\"Resultat: \", sac_optimisés[MASSE_MAX])\n#print(\"liste des sac_optimisés: \", sac_optimisés)\n```\n\n:::\n\nOn obtient le tableau suivant:\n\n+---------------------+--------------------+--------------------+\n| Capacité du sac(kg) | Valeur maximale(€) |   Contenu du sac   |\n+=====================+====================+====================+\n| 0                   | 0                  | [0, 0, 0, 0, 0, 0] |\n| 1                   | 2                  | [0, 0, 1, 0, 0, 0] |\n| 2                   | 4                  | [0, 0, 2, 0, 0, 0] |\n| 3                   | 6                  | [0, 0, 3, 0, 0, 0] |\n| 4                   | 10                 | [0, 0, 0, 0, 1, 0] |\n| 5                   | 12                 | [0, 0, 1, 0, 1, 0] |\n| 6                   | 14                 | [0, 0, 2, 0, 1, 0] |\n| 7                   | 16                 | [0, 0, 3, 0, 1, 0] |\n| 8                   | 20                 | [0, 0, 0, 0, 2, 0] |\n| 9                   | 22                 | [0, 0, 1, 0, 2, 0] |\n| 10                  | 24                 | [0, 0, 2, 0, 2, 0] |\n| 11                  | 26                 | [0, 0, 3, 0, 2, 0] |\n| 12                  | 30                 | [0, 0, 0, 0, 3, 0] |\n| 13                  | 32                 | [0, 0, 1, 0, 3, 0] |\n| 14                  | 34                 | [0, 0, 2, 0, 3, 0] |\n| 15                  | 36                 | [0, 0, 3, 0, 3, 0] |\n+---------------------+--------------------+--------------------+\n\nOn a donc maintenant en plus de la valeur, le contenu du sac. Je vous laisse vérifier que ce sac\nest bien _optimal_.\n\n## Conclusion\n\nDans ce chapitre nous avons vu comment résoudre des problèmes d'optimisation à l'aide de la\nprogrammation dynamique si la solution du problème peut-être construite à partir de la solution de\nses sous problèmes. Nous avons également vu comment rendre ces algorithmes plus efficaces\n(temporellement) en utilisant la technique des mémoïsation qui consite à stocker les solutions des\nsous-problèmes afin de ne pas les calculer plusieurs fois.\n\nMême si nous avons vu que deux exemples, les problèmes d'optimisations contraintes sont des\nproblèmes très courants et d'une grande importance pratique:\n\n- Gestion des stocks d'un magasin,\n- gestion d'emplois du temps,\n- optimisation des ressources d'un ordinateur, d'un réseau, des salles d'un batiment...\n\n\n::: ref\n\n- [Article Wikipedia sur la programmation dynamique][wikipedia]\n- [Lecture 13:The Knapsack Problem University of Eindhoven](eind)\n\n[eind]: http://www.es.ele.tue.nl/education/5MC10/Solutions/knapsack.pdf\n[wikipedia]: https://fr.wikipedia.org/wiki/Programmation_dynamique\n\n::: -->","tableOfContents":"","frontmatter":{"tags":["cours","terminale","lycée","numérique et sciences informatiques","nsi"],"tocHTML":""},"fields":{"classe":"tg","chapter":"Programmation dynamique*","matter":"nsi","nChapter":"4","part":"Algorithmique","nPart":"5"}}},"pageContext":{"slug":"tg/nsi/5-algorithmique/4-programmation-dynamique","chapter":"Programmation dynamique*"}},"staticQueryHashes":["604483588"],"slicesMap":{}}