---
tags: ["cours", "terminale", "lycée", "numérique et sciences informatiques", "nsi"]
---

::: programme

+------------------------+-------------------------------------+----------------------------------------+
|        Contenus        |         Capacités attendues         |              Commentaires              |
+========================+=====================================+========================================+
| Gestion des processus  | Décrire la création d’un            | À l’aide d’outils standard, il s’agit  |
| et des ressources par  | processus, l’ordonnancement de      | d’observer les processus actifs ou     |
| un système             | plusieurs processus par le          | en attente sur une machine.            |
| d’exploitation.        | système.                            | Une présentation débranchée de         |
|                        |                                     | l’interblocage peut être proposée.     |
|                        | Mettre en évidence le risque de     |                                        |
|                        | l’interblocage (deadlock).          |                                        |
|                        |                                     |                                        |
+------------------------+-------------------------------------+----------------------------------------+

:::

> Comme nous l'avons vu en première, le [système
> d'exploitation](/1g/nsi/6-architectures-materielles-et-systemes-dexploitation/3-systemes-dexploitation/)(Linux,
> Windows, MacOs...) est un programme particulier situé  entre le matériel et les applications qui
> a pour de rôle de coordonner l'ensemble des tâches qui sont exécutées par l'ordinateur. Cette
> année, nous allons voir comment le système d'exploitation charge les programmes dans la mémoire
> de masse et lance leur _exécution_ en leur créant des **processus** afin de pouvoir les gérer
> lors de leur exécution.


## Différence entre programme et processus

::: {.def terme="Programme"}

Un **programme est statique**: c'est un fichier contenant une suite d'instructions qui lorsqu'elles
sont exécutées modifient l'état du processeur et de la mémoire afin de réaliser une tâche donnée.

:::

Un même programme peut-être exécuté _plusieurs fois_ sur une même machine, il faut alors allouer à
chacune de ces exécution des ressources de mémoire et de processeur distinctes qui peuvent varier
au cours de ces exécutions.

::: {.def terme="Processus"}

Un **processus est dynamique**: c'est une instance d'exécution d'un programme sur une machine de son lancement jusqu'à sa fin.

:::

::: {.appli titre="Programmes et processus sous linux"}

<!-- TODO personnaliser image docker de binder -->

Si vous êtes sous linux ou OSX, vous pouvez simplement lancer un terminal pour ouvrir une console.
Sinon vous pouvez lancer une instance jupyterlab en ligne graĉe à
[![Binder](http://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/binder-examples/jupyterlab/master?urlpath=lab/tree/index.ipynb).

Sous linux, les programmes sont par
[convention](https://fr.wikipedia.org/wiki/Filesystem_Hierarchy_Standard) situées dans les dossiers
`bin` pour binaries en anglais:

- `/bin/`: commandes de base nécessaires au démarrage et à l'utilisation d'un système minimaliste.
- `/sbin/`: Exécutables pour les administrateurs (abréviation de system binaries, soit binaires
  système en français).
- `/usr/bin/`: Binaires exécutables qui ne sont pas déjà présents dans `/bin` et donc pas
  indispensables à un système minimaliste. 

On peut **lister les programmes** avec la commande `ls` et les exécuter en tapant leur nom dans une
console.

```bash{numberLines: false}
# la commande ls pour liste (vue en première)
ls /bin

ls /sbin

ls /usr/bin
```

Vous pouvez **afficher un programme** en particulier grâce à la commande `cat`.

```bash{numberLines: false}
cat /bin/ls
```
Comme vous le voyez c'est un fichier binaire car ce programme a été compilé pour s'exécuter plus
rapidement.

Vous pouvez **lancer un programme** en particulier en écrivant son `nom` (sans préciser son chemin
s'il appartient au `PATH`).

```bash{numberLines: false}
# affichage sortie
echo "Voulez-vous continuer"
# lecture entrée
read 
```

Maintenant si vous voulez **lister les processus** en cours d'exécution on utilise la commande `ps`.

```shell{promptUser: alice}{promptHost: dev.localhost}
# affiche mes processus en exécution
ps
# affiche tous les processus
ps -A
# affiche une aide simple
ps --help s

```

Voici un exemple de sortie avec l'option `-l` pour obtenir plus détails:

```{numberLines: false}
jovyan@jupyter-jupyterlab-2djupyterlab-2ddemo-2dgmyobfo6:~$ ps -lA
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S  1000       1       0  0  80   0 - 137942 epoll_ ?       00:00:45 jupyter-noteboo
0 Z  1000    2293       1  0  80   0 -     0 -      ?        00:00:00 dash <defunct>
4 S  1000    4031       1  0  80   0 -  5116 wait   pts/0    00:00:00 bash
4 S  1000    4900    4031  0  80   0 -  5083 select pts/0    00:00:00 bash
4 S  1000    5105       1  0  80   0 -  5116 wait   pts/1    00:00:00 bash
0 R  1000    5984    5105  0  80   0 -  6910 -      pts/1    00:00:00 ps
```

On peut créer des affichages particuliers par exemple pour voir quels processus sont les plus gourmands en mémoire: `ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem | head`

```{numberLines: false}
PID    PPID CMD                         %MEM %CPU
  1       0 /srv/conda/envs/notebook/bi  0.1 17.0
122       1 /srv/conda/envs/notebook/bi  0.0  4.6
 84       1 /bin/bash -l                 0.0  1.7
137      84 ps -eo pid,ppid,cmd,%mem,%c  0.0  0.0
138      84 head                         0.0  0.0
```


Enfin on peut **tuer un processus** avec la commande `kill`.

```{numberLines: false}
# tuer avec le PID processus id
kill 122
# tuer par le nom du programme ATTENTION cela tue votre instance binder
# pkill jupyter 
```

:::

## Les états d'un processus

Un processus n'a pas seulement besoin d'accéder au processeur, mais il a souvent besoin d'accéder à
des _ressources_ autres comme:

- La mémoire vive: RAM,
- La mémoire de masse: disques durs, clés USB, mémoire flash...
- La lecture ou l'écriture d'un fichier...
- Les périphériques d'entrée et de sortie: clavier, souris, écran, imprimante...

Ces _ressources_ externes étant beaucoup moins rapides que le processeur, elles **bloquent** les
processus lors de leur exécution.

Ainsi, lors de la vie d'un processus, celui-ci peut passer par trois états:

- **PRÊT**: le processus est lancé et _attend l'accès au processeur_.
- **ÉLU**: le processus a obtenu l'accès au processeur: il peut s'exécuter. 
- **BLOQUÉ**: le processus est en cours d'exécution, mais _attend une ressource_ en mémoire par
  exemple, il quitte le processeur pour libérer les ressources.

  <p><a href="https://commons.wikimedia.org/wiki/File:Diagrammed%C3%A9tatdunprocessus_1.png#/media/Fichier:Diagrammedétatdunprocessus_1.png"><img class="center" src="https://upload.wikimedia.org/wikipedia/commons/6/68/Diagrammed%C3%A9tatdunprocessus_1.png" alt="Diagrammedétatdunprocessus 1.png"></a><br>Image par <a href="https://en.wikipedia.org/wiki/fr:User:Pixeltoo" class="extiw" title="w:fr:User:Pixeltoo">Pixeltoo</a> sur <a href="https://en.wikipedia.org/wiki/fr:" class="extiw" title="w:fr:">Wikipédia français</a> — Transféré de <span class="plainlinks"><a class="external text" href="https://fr.wikipedia.org">fr.wikipedia</a></span> à Commons par <a href="//commons.wikimedia.org/wiki/User:Bloody-libu" title="User:Bloody-libu">Bloody-libu</a> utilisant <a href="https://iw.toolforge.org/commonshelper/" class="extiw" title="toollabs:commonshelper/">CommonsHelper</a>., Domaine public, <a href="https://commons.wikimedia.org/w/index.php?curid=17958966">Lien</a></p>

## Ordonnancement

À un instant donné, il y a souvent davantage de processus à exécuter que de processeurs.

Lors de leur lacement les processus sont placés dans une
[file](/tg/nsi/1-structures-de-donnees/2-structures-lineaires-piles-files) d'attente.

L’ordonnanceur désigne le composant du noyau du système d'exploitation choisissant l'ordre d'exécution des processus sur les processeurs d'un ordinateur.

Il existe divers algorithmes d'ordonnancement:

- **La méthode du tourniquet** (_Round Robin_): l'ordonnanceur traite la file d'attente comme une file circulaire et alloue successivement un temps processeur à chacun des processus de la file.
- **FIFO**: First In First Out (voir le [cours sur les
  files](/tg/nsi/1-structures-de-donnees/2-structures-lineaires-piles-files))
- **SJF** Shortest job first (SJF, ou SJN -Shortest Job Next-).
- ...

*[Article Wikipédia sur l'ordonnancement](https://fr.wikipedia.org/wiki/Ordonnancement_dans_les_systèmes_d'exploitation)*{.cite-source}

## Interblocage

::: {.def terme="interblocage"}

Un interblocage (ou étreinte fatale, _deadlock_ en anglais) est un phénomène qui peut se produire
lorsque des processus s'attendent mutuellement. 

:::


<p><a href="https://commons.wikimedia.org/wiki/File:Process_deadlock.svg#/media/Fichier:Process_deadlock.svg"><img class="half" src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/28/Process_deadlock.svg/1200px-Process_deadlock.svg.png" alt="Process deadlock.svg"></a><br>Par <span style="vertical-align:middle"><span style="display:inline-block;width:auto;white-space:nowrap;vertical-align:middle;float:ltr;direction:ltr;line-height:22px;height:24px;font-size:12px;margin:0px;padding:2px 4px 2px 6px;color:#000;background:#F8F9FA;border:1px solid #BAB;padding:2px 4px 2px 0px;"><a href="//commons.wikimedia.org/wiki/File:W3C_grn.svg" class="image"></a>&amp; &nbsp;Le code de ce fichier <a href="//commons.wikimedia.org/wiki/Help:SVG" title="Help:SVG">SVG</a> est <span class="plainlinks" style="background:#CE8"><a rel="nofollow" class="external text" href="//validator.w3.org/check?uri=https%3A%2F%2Fcommons.wikimedia.org%2Fwiki%2FSpecial%3AFilepath%2FProcess_deadlock.svg&amp;amp;doctype=Inline&amp;amp;ss=1#source">valide</a></span>.</span><span style="display:inline-block;width:auto;white-space:nowrap;vertical-align:middle;float:ltr;direction:ltr;line-height:22px;height:24px;font-size:12px;margin:0px;padding:2px 4px 2px 6px;color:#000;background:#F8F9FA;border:1px solid #BAB;"><a href="//commons.wikimedia.org/wiki/File:Dia.svg" class="image"></a>&amp;&nbsp;Ce <a href="https://fr.wikipedia.org/wiki/diagramme" class="extiw" title="fr:diagramme">diagramme</a> a été créé avec <a href="https://fr.wikipedia.org/wiki/Dia" class="extiw" title="fr:Dia">Dia</a> par <a href="//commons.wikimedia.org/wiki/User:Beta_M" title="User:Beta M">VolodyA! V Anarhist</a>.</span></span> — <span class="int-own-work" lang="fr">Travail personnel</span>, <a href="http://artlibre.org/licence/lal/en" title="Free Art License">FAL</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=18344504">Lien</a></p>

::: example

Deux processus en concurrence pour deux ressources dans un ordre opposé.

<p><a href="https://commons.wikimedia.org/wiki/File:Two_processes,_two_resources.gif#/media/File:Two_processes,_two_resources.gif"><img src="https://upload.wikimedia.org/wikipedia/commons/d/df/Two_processes%2C_two_resources.gif" alt="Two processes, two resources.gif"></a><br>By <a href="//commons.wikimedia.org/w/index.php?title=User:Abacoo&amp;amp;action=edit&amp;amp;redlink=1" class="new" title="User:Abacoo (page does not exist)">Abacoo</a> - <span class="int-own-work" lang="en">Own work</span>, <a href="https://creativecommons.org/licenses/by-sa/4.0" title="Creative Commons Attribution-Share Alike 4.0">CC BY-SA 4.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=47971211">Link</a></p>


- **A** Un seul processus se déroule.
- **B** Le processus ultérieur doit attendre.
- **C** Un blocage se produit lorsque le premier processus verrouille la première ressource en même temps que le second processus verrouille la seconde ressource.
- **D** Le blocage peut être résolu en annulant et en redémarrant le premier processus.

:::

::: {.plus titre="Conditions de Coffman"}

Coffman a prouvé en 1971 qu'il y a quatre conditions nécessaires pour qu'un blocage puisse avoir lieu.


Voir l'article Wikipédia [Conditions de
  Coffman](https://fr.wikipedia.org/wiki/Interblocage#Conditions_n%C3%A9cessaires) pour plus de détails.

:::

Il existe plusieurs façons de gérer les interblocages:

- les _ignorer_ ce qui était fait initialement par UNIX qui supposait que la fréquence des
  interblocages était faible et que la perte de données encourue à chaque fois est tolérable.
- les _détecter_: Un algorithme est utilisé pour suivre l'allocation des ressources et les états
  des processus, il annule et redémarre un ou plusieurs processus afin de supprimer le blocage
  détecté
- les _éviter_: des [algorithmes](https://en.wikipedia.org/wiki/Deadlock_prevention_algorithms)
  sont utilisés pour supprimer une des quatre conditions nécessaires à la possibilité de
  l'interblocage([Conditions de
  Coffman](https://fr.wikipedia.org/wiki/Interblocage#Conditions_n%C3%A9cessaires))