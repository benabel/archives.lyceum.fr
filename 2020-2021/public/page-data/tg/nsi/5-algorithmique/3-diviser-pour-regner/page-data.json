{"componentChunkName":"component---src-templates-cours-md-js","path":"/tg/nsi/5-algorithmique/3-diviser-pour-regner","result":{"data":{"markdownRemark":{"html":"<details class=\"programme\"><summary>Programme Officiel</summary><div><table class=\"table table-bordered table-hover\"><thead class=\"table-warning\"><tr><th colspan=\"1\" rowspan=\"1\"><p>Contenus</p></th><th colspan=\"1\" rowspan=\"1\"><p>Capacités attendues</p></th><th colspan=\"1\" rowspan=\"1\"><p>Commentaires</p></th></tr></thead><tbody><tr><td colspan=\"1\" rowspan=\"1\"><p>Méthode « diviser pour\nrégner ».</p></td><td colspan=\"1\" rowspan=\"1\"><p>Écrire un algorithme utilisant la\nméthode « diviser pour régner ».</p></td><td colspan=\"1\" rowspan=\"1\"><p>La rotation d’une image bitmap\nd’un quart de tour avec un coût en\nmémoire constant est un bon\nexemple.</p><p>L’exemple du tri fusion permet\négalement d’exploiter la\nrécursivité et d’exhiber un\nalgorithme de coût en n log 2 n\ndans les pires des cas.</p></td></tr></tbody></table></div><a class=\"lien-programme\" href=\"../programme/\">Lien vers le programme complet</a></details>\n<div class=\"intro clearfix\"><p><a href=\"https://commons.wikimedia.org/wiki/File:Merge-sort-example-300px.gif#/media/Fichier:Merge-sort-example-300px.gif\"><img class=\"half right\" src=\"https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif\" alt=\"Merge-sort-example-300px.gif\"></a><br>Par <a href=\"//commons.wikimedia.org/w/index.php?title=User:Swfung8&amp;action=edit&amp;redlink=1\" class=\"new\" title=\"User:Swfung8 (page does not exist)\">Swfung8</a> — <span class=\"int-own-work\" lang=\"fr\">Travail personnel</span>, <a href=\"https://creativecommons.org/licenses/by-sa/3.0\" title=\"Creative Commons Attribution-Share Alike 3.0\">CC BY-SA 3.0</a>, <a href=\"https://commons.wikimedia.org/w/index.php?curid=14961648\">Lien</a></p><blockquote>\n<p>Nous avons vu en première deux algorithmes de tris assez naturels, mais peu efficaces: le tri par\ninsertion et le tri par sélection. Cette année, nous allons étudier un algorithme beaucoup plus\nefficace et très utilisé inventé par John Von Neumann en 1945: le tri par fusion. Cet algorithme\nnous permettra d'illustrer la méthode diviser pour régner que nous avions déjà vue lors de la\nrecherche dichotomique.</p>\n</blockquote></div>\n<h2 id=\"complexité-des-algorithmes-de-tri\" style=\"position:relative;\"><a href=\"#complexit%C3%A9-des-algorithmes-de-tri\" aria-label=\"complexité des algorithmes de tri permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexité des algorithmes de tri</h2>\n<p>En <a href=\"../../..//1g/nsi/8-algorithmique/2-algorithmes-de-tri\">première</a>, nous avons vu deux algorithmes peu performants:</p>\n<ul>\n<li>le tri par sélection qui a une complexité <em>quadratique</em> dans le pire des cas, le meilleur des cas\net en moyenne.</li>\n<li>le tri par insertion qui a une complexité <em>linéaire</em> dans le meilleur des cas, et <em>quadratique</em>\ndans le pire des cas et en moyenne.</li>\n</ul>\n<p>Ces algorithmes ne sont pas utilisés en pratique car peu efficaces. En effet, il a été prouvé que\ndans le pire des cas et en moyenne, on pouvait au mieux obtenir une complexité <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n \\log(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>.</p>\n<p>Cela fait une grande différence car <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>log</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>⋘</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">\\log(n) \\lll n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel amsrm\">⋘</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, en effet:</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>log</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>10</mn></mrow><annotation encoding=\"application/x-tex\">\\log(n) = 10</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">10</span></span></span></span> pour <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><msup><mn>2</mn><mn>10</mn></msup><mo>=</mo><mn>1024</mn></mrow><annotation encoding=\"application/x-tex\">n = 2^{10} = 1024</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">10</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1024</span></span></span></span> </li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>log</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>100</mn></mrow><annotation encoding=\"application/x-tex\">\\log(n) = 100</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">100</span></span></span></span> pour <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><msup><mn>2</mn><mn>100</mn></msup><mo>=</mo><mn>1267650600228229401496703205376</mn></mrow><annotation encoding=\"application/x-tex\">n = 2^{100} = 1267650600228229401496703205376</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">100</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1267650600228229401496703205376</span></span></span></span></li>\n</ul>\n<p>On avait déjà rencontré ce type d'améliorations entre la recherche en table et la recherche\ndichotomique qui utilisait le principe «Diviser pour régner».</p>\n<h2 id=\"le-principe-de-diviser-pour-régner\" style=\"position:relative;\"><a href=\"#le-principe-de-diviser-pour-r%C3%A9gner\" aria-label=\"le principe de diviser pour régner permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Le principe de diviser pour régner</h2>\n<p>Le principe de diviser pour régner consiste à ramener la résolution d'un problème sur N données à\nla résolution d'un problème sur la moitié des données et poursuivre ce découpage jusqu'à ce que le\nproblème devienne évident(<em>par exemple trier un tableau d'une donnée</em>). Une fois que les solutions\ndes sous problèmes ont été trouvées, on les combine pour obtenir la solution du problème complet.</p>\n<blockquote>\n<ul>\n<li><em>Diviser</em> : découper un problème initial en sous-problèmes ;</li>\n<li><em>Régner</em> : résoudre les sous-problèmes (récursivement ou directement s'ils sont assez petits) ;</li>\n<li><em>Combiner</em> : calculer une solution au problème initial à partir des solutions des sous-problèmes.</li>\n</ul>\n</blockquote>\n<p><em class=\"cite-source\"><a href=\"https://fr.wikipedia.org/wiki/Diviser_pour_r%C3%A9gner_(informatique)\">Article Wikipedia Diviser pour régner</a></em></p>\n<p><a href=\"https://commons.wikimedia.org/wiki/File:Trois_%C3%A9tapes_illustr%C3%A9_avec_l%27algorithme_du_tri_fusion.svg#/media/Fichier:Trois_étapes_illustré_avec_l'algorithme_du_tri_fusion.svg\"><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4a/Trois_%C3%A9tapes_illustr%C3%A9_avec_l%27algorithme_du_tri_fusion.svg/1200px-Trois_%C3%A9tapes_illustr%C3%A9_avec_l%27algorithme_du_tri_fusion.svg.png\" alt=\"Trois étapes illustré avec l'algorithme du tri fusion.svg\"></a><br>Image par <a href=\"//commons.wikimedia.org/w/index.php?title=User:Fschwarzentruber&amp;action=edit&amp;redlink=1\" class=\"new\" title=\"User:Fschwarzentruber (page does not exist)\">Fschwarzentruber</a> — <span class=\"int-own-work\" lang=\"fr\">Travail personnel</span>, <a href=\"https://creativecommons.org/licenses/by-sa/4.0\" title=\"Creative Commons Attribution-Share Alike 4.0\">CC BY-SA 4.0</a>, <a href=\"https://commons.wikimedia.org/w/index.php?curid=47869242\">Lien</a></p>\n<h2 id=\"le-tri-fusion\" style=\"position:relative;\"><a href=\"#le-tri-fusion\" aria-label=\"le tri fusion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Le tri fusion</h2>\n<p>Le tri fusion s'appuie sur le fait que fusionner deux tableaux triés en un tableau trié se fait en\nun temps linéaire <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>.</p>\n<div class=\"example\"><p>Pour fusionner ces deux tableaux triés:</p><p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 415px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 46.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABo0lEQVQoz2WQS2+jMACE8/9/TXtsj5WSKAoEHPOyYwgPGwwmOHUJ5pHAil1pD7tznJlPI83Gz3xMUZAGRmDGIt6BnR0CN3F3YBfn8TiOy7KUt/LoH3GB4RUefcNP/a21TXiycRLHZ75NbMwxytHpcnISx01dcAWX7DIOK0w5hTF0Eud8hRaxndQ1sEkY2eRVzkpGOS1vZUxjIYWbuTGLxV1wwV+v17Is8i6ZYBaxqqbKy5xy+ifdLP9pmqdbf5vn+a8zL3Ot6/E1/tPczL81DEOv+77vtdbP8ala9e6+16pepqVpmzf4ph5qGiat9dAPutPjMM7zvC7rTqdlSoowKqJEpChDUssP8OEVHquZSUwjN3ByoQ3N77kXeWVbhSzsum6Fu0cX5dH5esYUm8j0qLeH+0xQE51ABMIq/Dp82cQGBMAIurH7uf0MUqR7vcJt2wYZMrG5nhwBE5snYlmhZSDDZ/6JWMfgePAO1sWCCTSQsXf2NgGPx2OFn89n892IpqqaqpZ1WZeqU1zwRjW1rLngqlOF4FJJ+SOLqlCdElJM0/QL4k/laq1Y6AAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Fusion de deux tableaux à 3 et 4 éléments\"\n        title=\"Fusion de deux tableaux à 3 et 4 éléments\"\n        src=\"/2020-2021/static/c9754d3313495dac5f572ea606394a83/73926/fusion-2-tab-tries.png\"\n        srcset=\"/2020-2021/static/c9754d3313495dac5f572ea606394a83/8514f/fusion-2-tab-tries.png 192w,\n/2020-2021/static/c9754d3313495dac5f572ea606394a83/804b2/fusion-2-tab-tries.png 384w,\n/2020-2021/static/c9754d3313495dac5f572ea606394a83/73926/fusion-2-tab-tries.png 415w\"\n        sizes=\"(max-width: 415px) 100vw, 415px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p><p>Il suffit d'une itération sur les deux listes en même temps donc <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> ici 5 itérations pour une\nliste de 7 éléments:</p><ol>\n<li>On considère 3 et 9, on place 3, et on avance sur la 1ère liste.</li>\n<li>On considère 27 et 9, on place 9, et on avance sur la 2e liste.</li>\n<li>On considère 27 et 10, on place 10, ...</li>\n<li>On considère 27 et 82, on place 27, ...</li>\n<li>On considère 38 et 82, on place 38, ...</li>\n<li>On considère 43 et 82, on place 43, et on voit qu'on est arrivé au bout de la première liste\nOn place maintenant tous les éléments restants de la deuxième liste.</li>\n</ol></div>\n<p>D'autres part, le découpage récursif d'un tableau jusqu'à arriver au cas terminal : tableau trié de\nun élément est en <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>log</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\log(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>. Ce qui fait bien une complexité en <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mi>n</mi><mi>log</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O n\\log(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>, on ne peut pas faire\nmieux.</p>\n<p>On va donc séparer notre algorithme en deux fonctions, une qui réalise la fusion et l'autre qui\nréalise la récursion du tri(le découpage). Ces deux opérations sont symbolisées sur l'illustration\nci-dessous:</p>\n<ul>\n<li>rouge: division</li>\n<li>vert: fusion.</li>\n</ul>\n<p><a href=\"https://commons.wikimedia.org/wiki/File:Merge_sort_algorithm_diagram.svg#/media/File:Merge_sort_algorithm_diagram.svg\"><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/e/e6/Merge_sort_algorithm_diagram.svg/1200px-Merge_sort_algorithm_diagram.svg.png\" alt=\"Merge sort algorithm diagram.svg\"></a><br>By <a href=\"https://en.wikipedia.org/wiki/User:VineetKumar\" class=\"extiw\" title=\"wikipedia:User:VineetKumar\">VineetKumar</a> at <a href=\"https://en.wikipedia.org/wiki/\" class=\"extiw\" title=\"wikipedia:\">English Wikipedia</a> - Transferred from <span class=\"plainlinks\"><a class=\"external text\" href=\"https://en.wikipedia.org\">en.wikipedia</a></span> to Commons by <a href=\"https://en.wikipedia.org/wiki/User:Eric_Bauman\" class=\"extiw\" title=\"en:User:Eric Bauman\">Eric Bauman</a> using <a href=\"https://tools.wmflabs.org/commonshelper/\" class=\"extiw\" title=\"toollabs:commonshelper/\">CommonsHelper</a>., Public Domain, <a href=\"https://commons.wikimedia.org/w/index.php?curid=8004317\">Link</a></p>\n<h3 id=\"algorithme-de-fusion\" style=\"position:relative;\"><a href=\"#algorithme-de-fusion\" aria-label=\"algorithme de fusion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Algorithme de fusion</h3>\n<p>Voici l'algorithme de fusion de deux tableaux triés en un seul.</p>\n<p>Tout d'abord en pseudo-code:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">FUNCTION fusion(T1, T2)\n    // T1 et T2 sont deux tableaux triés\n    \n    // Initialisation\n    i1 &lt;- 0   // indice du 1er tableau\n    i2 &lt;- 0   // indice du 2e tableau\n    T &lt;- []   // liste vide destinée à accueillir les éléments triés\n\n    // Boucle\n    TANT QUE l&#39;on a pas atteint la fin d&#39;un des tableaux\n        SI T1[i1] &lt;= T2[i2] ALORS\n            Insérer T1[i1] à la fin de T\n            incrémenter i1\n        SINON\n            Insérer T2[i2] à la fin de T\n            incrémenter i2\n        FIN SI\n    FIN TANT QUE\n    \n    // Finalisation\n    Insérer les éléments restants du tableau non vide à la fin de T\n    \n    RENVOYER T</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Et voici une implémentation en python:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-python line-numbers\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">fusion</span> <span class=\"token punctuation\">(</span>T1<span class=\"token punctuation\">,</span> T2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># Initialisation</span>\n    N1<span class=\"token punctuation\">,</span> N2 <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>T1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>T2<span class=\"token punctuation\">)</span>\n    i1 <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    i2 <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    T <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n    <span class=\"token comment\"># Boucle</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i1 <span class=\"token operator\">&lt;</span> N1<span class=\"token punctuation\">)</span> <span class=\"token keyword\">and</span> <span class=\"token punctuation\">(</span>i2 <span class=\"token operator\">&lt;</span> N2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        x1<span class=\"token punctuation\">,</span> x2 <span class=\"token operator\">=</span> T1<span class=\"token punctuation\">[</span>i1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> T2<span class=\"token punctuation\">[</span>i2<span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">if</span> x1 <span class=\"token operator\">&lt;=</span> x2<span class=\"token punctuation\">:</span>\n            T<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>x1<span class=\"token punctuation\">)</span>\n            i1 <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            T<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>x2<span class=\"token punctuation\">)</span>\n            i2 <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n\n    <span class=\"token comment\"># Finalisation</span>\n    <span class=\"token keyword\">if</span> i1 <span class=\"token operator\">&lt;</span> N1<span class=\"token punctuation\">:</span>\n        T <span class=\"token operator\">+=</span> T1<span class=\"token punctuation\">[</span>i1<span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">if</span> i2 <span class=\"token operator\">&lt;</span> N2<span class=\"token punctuation\">:</span>\n        T <span class=\"token operator\">+=</span> T2<span class=\"token punctuation\">[</span>i2<span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">return</span> T</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Un petit test dans la console <code class=\"language-text\">ipython</code> permet de vérifier sur un cas simple la fusion:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">&gt;&gt;&gt; fusion([3,6,8], [2,5,7,12])\n[2, 3, 5, 6, 7, 8, 12]</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h3 id=\"algorithme-de-tri-fusion\" style=\"position:relative;\"><a href=\"#algorithme-de-tri-fusion\" aria-label=\"algorithme de tri fusion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Algorithme de tri fusion</h3>\n<p>Voici l'algorithme récursif de tri fusion qui utilise la fonction <code class=\"language-text\">fusion</code> définie précédemment.</p>\n<p>Tout d'abord en pseudo-code, on retrouve des techniques de découpage du tableau en deux avec des\ndivisions entières <code class=\"language-text\">//</code> vues dans la recherche dichotomique.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">FONCTION tri_fusion (T)\n    N &lt;- Longueur de T\n\n    // Cas terminal\n    SI N == 1 ALORS\n        RENVOYER T\n    FIN SI\n\n    // Recursion sur les deux demi-tableaux sinon\n    T1 &lt;- tri_fusion(T[0:N//2]\n    T2 &lt;- tri_fusion(T[N//2:N]\n\n    // Renvoi des la fusion des deux tableaux\n    RENVOYER fusion(T1, T2)</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Et voici une implémentation en python:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-python line-numbers\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">tri_fusion</span> <span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    N <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> N <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> T\n    \n    T1 <span class=\"token operator\">=</span> tri_fusion<span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span>N<span class=\"token operator\">//</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    T2 <span class=\"token operator\">=</span> tri_fusion<span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">[</span>N<span class=\"token operator\">//</span><span class=\"token number\">2</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    \n    <span class=\"token keyword\">return</span> fusion<span class=\"token punctuation\">(</span>T1<span class=\"token punctuation\">,</span> T2<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>On fait un petit test sur une liste quelconque.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">&gt;&gt;&gt; tri_fusion([0, 25, 36, 41, 1, 465, 2, 3, 987])\n[0, 1, 2, 3, 25, 36, 41, 465, 987]</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h3 id=\"conclusion\" style=\"position:relative;\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h3>\n<p>Nous avons vu dans ce chapitre un algorithme particulièrement <em>élégant et efficace</em> pour trier des\néléments. Bien sûr dans la pratique des contraintes de mémoire peuvent intervenir, et là au\ncontraire cet algorithme se révélera peu performant, car l'utilisation de la récursivité et de la\ntable <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> intermédiaire le rend très gourmand en mémoire.</p>\n<p>La méthode «diviser pour régner» est une méthode très efficace pour résoudre des problèmes complexes\nen les <em>découpant en sous problèmes indépendants</em>. Par contre, on verra dans le prochain chapitre\nqu'elle devient inefficace si les sous-problèmes se chevauchent, et il conviendra alors d'utiliser\nune nouvelle technique appelée <em>« Programmation dynamique »</em>.</p>\n<div class=\"ref\"><ul>\n<li><a href=\"https://fr.wikipedia.org/wiki/Diviser_pour_r%C3%A9gner_(informatique)\">Article Wikipedia Diviser pour régner</a></li>\n<li><a href=\"https://editions.lavoisier.fr/etudes-superieures/informatique-mp-pc-pt-psi/preaux/tec-et-doc/le-tout-en-un/livre/9782743022976\">Informatique MP-PC-PT-PSI</a></li>\n</ul></div>","tableOfContents":"<ul>\n<li><a href=\"#complexit%C3%A9-des-algorithmes-de-tri\">Complexité des algorithmes de tri</a></li>\n<li><a href=\"#le-principe-de-diviser-pour-r%C3%A9gner\">Le principe de diviser pour régner</a></li>\n<li>\n<p><a href=\"#le-tri-fusion\">Le tri fusion</a></p>\n<ul>\n<li><a href=\"#algorithme-de-fusion\">Algorithme de fusion</a></li>\n<li><a href=\"#algorithme-de-tri-fusion\">Algorithme de tri fusion</a></li>\n<li><a href=\"#conclusion\">Conclusion</a></li>\n</ul>\n</li>\n</ul>","frontmatter":{"tags":["cours","terminale","lycée","numérique et sciences informatiques","nsi"]},"fields":{"classe":"tg","chapter":"Diviser pour régner","matter":"nsi","nChapter":"3","part":"Algorithmique","nPart":"5"}}},"pageContext":{"slug":"tg/nsi/5-algorithmique/3-diviser-pour-regner","chapter":"Diviser pour régner"}},"staticQueryHashes":["604483588"]}