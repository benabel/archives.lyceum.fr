{"componentChunkName":"component---src-templates-cours-md-js","path":"/tg/nsi/5-algorithmique/2-diviser-pour-regner","result":{"data":{"markdownRemark":{"html":"<details class=\"programme\">\n<summary>\nProgramme Officiel\n</summary>\n<!-- \n+------------------------+-----------------------------------+------------------------------------+\n|        Contenus        |        Capacités attendues        |            Commentaires            |\n+========================+===================================+====================================+\n| Méthode « diviser pour | Écrire un algorithme utilisant la | La rotation d’une image bitmap     |\n| régner ».              | méthode « diviser pour régner ».  | d’un quart de tour avec un coût en |\n|                        |                                   | mémoire constant est un bon        |\n|                        |                                   | exemple.                           |\n|                        |                                   |                                    |\n|                        |                                   | L’exemple du tri fusion permet     |\n|                        |                                   | également d’exploiter la           |\n|                        |                                   | récursivité et d’exhiber un        |\n|                        |                                   | algorithme de coût en n log 2 n    |\n|                        |                                   | dans les pires des cas.            |\n+------------------------+-----------------------------------+------------------------------------+ -->\n<a class=\"lien-programme\" href=\"../programme/\">Lien vers le programme\ncomplet</a>\n</details>\n<div class=\"intro\">\n<p><wc-wikimage class=\"half right\" title=\"Merge-sort-example-300px.gif\" caption=\"Le tri fusion est un algorithme de tri utilisant la méthode « Diviser pour Régner » tout comme la recherche dichotomique vue en première.\"></wc-wikimage></p>\n<blockquote>\n<p>Nous avons vu en première deux algorithmes de tris assez naturels,\nmais peu efficaces: le tri par insertion et le tri par sélection.\nCette année, nous allons étudier un algorithme beaucoup plus efficace\net très utilisé inventé par John Von Neumann en 1945: le tri par\nfusion. Cet algorithme nous permettra d'illustrer la méthode diviser\npour régner que nous avions déjà vue lors de la recherche\ndichotomique.</p>\n</blockquote>\n</div>\n<h2 id=\"complexité-des-algorithmes-de-tri\" style=\"position:relative;\"><a href=\"#complexit%C3%A9-des-algorithmes-de-tri\" aria-label=\"complexité des algorithmes de tri permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Complexité des algorithmes de tri</h2>\n<p>En\n<span><a href=\"../../..//1g/nsi/8-algorithmique/2-algorithmes-de-tri\">première</a></span>,\nnous avons vu deux algorithmes peu performants:</p>\n<ul>\n<li>le tri par sélection qui a une complexité <em>quadratique</em> dans le pire\ndes cas, le meilleur des cas et en moyenne.</li>\n<li>le tri par insertion qui a une complexité <em>linéaire</em> dans le\nmeilleur des cas, et <em>quadratique</em> dans le pire des cas et en\nmoyenne.</li>\n</ul>\n<p>Ces algorithmes ne sont pas utilisés en pratique, car peu efficaces. En\neffet, il a été prouvé que dans le pire des cas et en moyenne, on\npouvait au mieux obtenir une complexité <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n \\log(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>Cela fait une grande différence car <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>log</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>⋘</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">\\log(n) \\lll n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel amsrm\">⋘</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span>, en effet:</p>\n<ul>\n<li><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>log</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>10</mn></mrow><annotation encoding=\"application/x-tex\">\\log(n) = 10</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">10</span></span></span></span></span> pour <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><msup><mn>2</mn><mn>10</mn></msup><mo>=</mo><mn>1024</mn></mrow><annotation encoding=\"application/x-tex\">n = 2^{10} = 1024</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">10</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1024</span></span></span></span></span></li>\n<li><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>log</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>100</mn></mrow><annotation encoding=\"application/x-tex\">\\log(n) = 100</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">100</span></span></span></span></span> pour <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><msup><mn>2</mn><mn>100</mn></msup><mo>=</mo><mn>1267650600228229401496703205376</mn></mrow><annotation encoding=\"application/x-tex\">n = 2^{100} = 1267650600228229401496703205376</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">100</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1267650600228229401496703205376</span></span></span></span></span></li>\n</ul>\n<p>On avait déjà rencontré ce type d'améliorations entre la recherche en\ntable et la recherche dichotomique qui utilisait le principe «Diviser\npour régner».</p>\n<h2 id=\"le-principe-de-diviser-pour-régner\" style=\"position:relative;\"><a href=\"#le-principe-de-diviser-pour-r%C3%A9gner\" aria-label=\"le principe de diviser pour régner permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Le principe de diviser pour régner</h2>\n<p>Le principe de diviser pour régner consiste à ramener la résolution d'un\nproblème sur N données à la résolution d'un problème sur la moitié des\ndonnées et poursuivre ce découpage jusqu'à ce que le problème devienne\névident(<em>par exemple trier un tableau d'une donnée</em>). Une fois que les\nsolutions des sous problèmes ont été trouvées, on les combine pour\nobtenir la solution du problème complet.</p>\n<blockquote>\n<ul>\n<li><em>Diviser</em> : découper un problème initial en sous-problèmes ;</li>\n<li><em>Régner</em> : résoudre les sous-problèmes (récursivement ou\ndirectement s'ils sont assez petits) ;</li>\n<li><em>Combiner</em> : calculer une solution au problème initial à partir\ndes solutions des sous-problèmes.</li>\n</ul>\n</blockquote>\n<p><span><a href=\"https://fr.wikipedia.org/wiki/Diviser_pour_r%C3%A9gner_(informatique)\">Article Wikipedia Diviser pour\nrégner</a></span>{.cite-source}</p>\n<p><wc-wikimage title=\"Trois_étapes_illustré_avec_l'algorithme_du_tri_fusion.svg\" caption=\"Au lieu de trier la liste entière, nous allons couper la liste en plus petites listes qui seront faciles à trier. On combinera ensuite les petites listes triées obtenues en une seule.\"></wc-wikimage></p>\n<h2 id=\"le-tri-fusion\" style=\"position:relative;\"><a href=\"#le-tri-fusion\" aria-label=\"le tri fusion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Le tri fusion</h2>\n<p>Le tri fusion s'appuie sur le fait que fusionner deux tableaux triés en\nun tableau trié se fait en un temps linéaire <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<div class=\"example\">\n<p>Pour fusionner ces deux tableaux triés:</p>\n<p><span><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 415px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.2972972972973%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABo0lEQVQoz2WQS2+jMACE8/9/TXtsj5WSKAoEHPOyYwgPGwwmOHUJ5pHAil1pD7tznJlPI83Gz3xMUZAGRmDGIt6BnR0CN3F3YBfn8TiOy7KUt/LoH3GB4RUefcNP/a21TXiycRLHZ75NbMwxytHpcnISx01dcAWX7DIOK0w5hTF0Eud8hRaxndQ1sEkY2eRVzkpGOS1vZUxjIYWbuTGLxV1wwV+v17Is8i6ZYBaxqqbKy5xy+ifdLP9pmqdbf5vn+a8zL3Ot6/E1/tPczL81DEOv+77vtdbP8ala9e6+16pepqVpmzf4ph5qGiat9dAPutPjMM7zvC7rTqdlSoowKqJEpChDUssP8OEVHquZSUwjN3ByoQ3N77kXeWVbhSzsum6Fu0cX5dH5esYUm8j0qLeH+0xQE51ABMIq/Dp82cQGBMAIurH7uf0MUqR7vcJt2wYZMrG5nhwBE5snYlmhZSDDZ/6JWMfgePAO1sWCCTSQsXf2NgGPx2OFn89n892IpqqaqpZ1WZeqU1zwRjW1rLngqlOF4FJJ+SOLqlCdElJM0/QL4k/laq1Y6AAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Fusion de deux tableaux à 3 et 4\néléments\"\n        title=\"fig:\"\n        src=\"/2021-2022/static/c9754d3313495dac5f572ea606394a83/73926/fusion-2-tab-tries.png\"\n        srcset=\"/2021-2022/static/c9754d3313495dac5f572ea606394a83/12f09/fusion-2-tab-tries.png 148w,\n/2021-2022/static/c9754d3313495dac5f572ea606394a83/e4a3f/fusion-2-tab-tries.png 295w,\n/2021-2022/static/c9754d3313495dac5f572ea606394a83/73926/fusion-2-tab-tries.png 415w\"\n        sizes=\"(max-width: 415px) 100vw, 415px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></span></p>\n<p>Il suffit d'une itération sur les deux listes en même temps donc <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>\nici 5 itérations pour une liste de 7 éléments:</p>\n<ol>\n<li>On considère 3 et 9, on place 3, et on avance sur la 1ère liste.</li>\n<li>On considère 27 et 9, on place 9, et on avance sur la 2e liste.</li>\n<li>On considère 27 et 10, on place 10, ...</li>\n<li>On considère 27 et 82, on place 27, ...</li>\n<li>On considère 38 et 82, on place 38, ...</li>\n<li>On considère 43 et 82, on place 43, et on voit qu'on est arrivé au\nbout de la première liste On place maintenant tous les éléments\nrestants de la deuxième liste.</li>\n</ol>\n</div>\n<p>D'autre part, le découpage récursif d'un tableau jusqu'à arriver au cas\nterminal : tableau trié d'un seul élément est en <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>log</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\log(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>. Ce qui fait\nbien une complexité en <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\log(n))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">))</span></span></span></span></span>, on ne peut pas faire mieux.</p>\n<p>On va donc séparer notre algorithme en deux fonctions, une qui réalise\nla fusion et l'autre qui réalise la récursion du tri(le découpage). Ces\ndeux opérations sont symbolisées sur l'illustration ci-dessous:</p>\n<ul>\n<li>rouge: division</li>\n<li>vert: fusion.</li>\n</ul>\n<p><wc-wikimage title=\"Merge_sort_algorithm_diagram.svg\" caption=\"Une fois la liste découpée, le problème du tri est simple car un tableau de un élément est forcément trié! Il ne reste alors plus qu'à fusionner.\"></wc-wikimage></p>\n<h3 id=\"algorithme-de-fusion\" style=\"position:relative;\"><a href=\"#algorithme-de-fusion\" aria-label=\"algorithme de fusion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Algorithme de fusion</h3>\n<p>Voici l'algorithme de fusion de deux tableaux triés en un seul.</p>\n<p>Tout d'abord en pseudo-code:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">fonction fusion(tbl1: Tableau, tbl2: Tableau)\n    // tbl1 et tbl2 sont deux tableaux triés\n    \n    // Initialisation\n    i1 &lt;- 0   // indice du 1er tableau\n    i2 &lt;- 0   // indice du 2e tableau\n    tbl &lt;- []   // liste vide destinée à accueillir les éléments triés\n\n    // Boucle\n    TANT QUE l'on a pas atteint la fin d'un des tableaux\n        SI tbl1[i1] &lt;= tbl2[i2] ALORS\n            Insérer tbl1[i1] à la fin de tbl\n            incrémenter i1\n        SINON\n            Insérer tbl2[i2] à la fin de tbl\n            incrémenter i2\n        FIN SI\n    FIN TANT QUE\n    \n    // Finalisation\n    // Insérer les éléments restants du tableau non vide à la fin de tbl\n    SI i1 &lt; longueur de tbl1 ALORS\n        Insérer tous les éléments restants de tbl1 à la fin de tbl\n    SINON SI i2 &lt; longueur de tbl2 ALORS\n        Insérer tous les éléments restants de tbl2 à la fin de tbl\n    \n    RENVOYER tbl</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Et voici une implémentation en python:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-python line-numbers\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">fusion</span> <span class=\"token punctuation\">(</span>tbl1<span class=\"token punctuation\">:</span> <span class=\"token builtin\">list</span><span class=\"token punctuation\">,</span> tbl2<span class=\"token punctuation\">:</span> <span class=\"token builtin\">list</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">list</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># Initialisation</span>\n    N1<span class=\"token punctuation\">,</span> N2 <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>tbl1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>tbl2<span class=\"token punctuation\">)</span>\n    i1 <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    i2 <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    tbl <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n    <span class=\"token comment\"># Boucle sur les deux tableaux</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i1 <span class=\"token operator\">&lt;</span> N1<span class=\"token punctuation\">)</span> <span class=\"token keyword\">and</span> <span class=\"token punctuation\">(</span>i2 <span class=\"token operator\">&lt;</span> N2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        x1<span class=\"token punctuation\">,</span> x2 <span class=\"token operator\">=</span> tbl1<span class=\"token punctuation\">[</span>i1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> tbl2<span class=\"token punctuation\">[</span>i2<span class=\"token punctuation\">]</span>\n        <span class=\"token comment\"># si x1 &lt; x2  on ajoute l'élément x1 à tbl</span>\n        <span class=\"token keyword\">if</span> x1 <span class=\"token operator\">&lt;=</span> x2<span class=\"token punctuation\">:</span>\n            tbl<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>x1<span class=\"token punctuation\">)</span>\n            i1 <span class=\"token operator\">=</span> i1 <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n        <span class=\"token comment\"># sinon on ajoute l'élément x2</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            tbl<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>x2<span class=\"token punctuation\">)</span>\n            i2 <span class=\"token operator\">=</span> i2 <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n\n    <span class=\"token comment\"># Finalisation: On ajoute les éléments restants du tableau non vide restant</span>\n    <span class=\"token comment\"># Si tbl1 n'a pas été entièrement vidé, on ajoute ses éléments restants</span>\n    <span class=\"token keyword\">if</span> i1 <span class=\"token operator\">&lt;</span> N1<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>i1<span class=\"token punctuation\">,</span> N1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            tbl<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>tbl1<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># Sinon on ajoute les éléments de tbl2 restants</span>\n    <span class=\"token keyword\">elif</span> i2 <span class=\"token operator\">&lt;</span> N2<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>i2<span class=\"token punctuation\">,</span> N2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            tbl<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>tbl2<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        \n    <span class=\"token keyword\">return</span> tbl</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Un petit test dans la console <code class=\"language-text\">ipython</code> permet de vérifier sur un cas\nsimple la fusion:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">>>> fusion([3,6,8], [2,5,7,12])\n[2, 3, 5, 6, 7, 8, 12]</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h3 id=\"algorithme-de-tri-fusion\" style=\"position:relative;\"><a href=\"#algorithme-de-tri-fusion\" aria-label=\"algorithme de tri fusion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Algorithme de tri fusion</h3>\n<p>Voici l'algorithme récursif de tri fusion qui utilise la fonction\n<code class=\"language-text\">fusion</code> définie précédemment.</p>\n<p>Tout d'abord en pseudo-code, on retrouve des techniques de découpage du\ntableau en deux avec des divisions entières <code class=\"language-text\">//</code> vues dans la recherche\ndichotomique.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">fonction tri_fusion(tbl: Tableau)\n    N &lt;- Longueur de tbl\n\n    // Cas terminal: une liste de un élément est forcément triée\n    SI N == 1 ALORS\n        RENVOYER tbl\n    FIN SI\n\n    // Recursion sur les deux demi-tableaux sinon\n    tbl1 &lt;- liste des N//2 premiers éléments de tbl\n    tbl2 &lt;- liste des N//2 derniers éléments de tbl\n\n    // Renvoi des la fusion des deux tableaux\n    RENVOYER fusion(tri_fusion(tbl1), tri_fusion(tbl2))</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Et voici une implémentation en python qui utilise les <span><a href=\"https://www.lyceum.fr/1g/nsi/3-representation-des-donnees-types-construits/2-tableaux#tableau-donn%C3%A9-en-compr%C3%A9hension\">listes en\ncompréhension</a></span>:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-python line-numbers\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">tri_fusion</span> <span class=\"token punctuation\">(</span>tbl<span class=\"token punctuation\">:</span> <span class=\"token builtin\">list</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">list</span><span class=\"token punctuation\">:</span>\n    N <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>tbl<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># cas de base: un tableau de zéro ou un élément est forcément trié!</span>\n    <span class=\"token keyword\">if</span> N <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> tbl\n    \n    <span class=\"token comment\"># on coupe le tableau en deux</span>\n    tbl1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>tbl<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>N<span class=\"token operator\">//</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    tbl2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>tbl<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>N<span class=\"token operator\">//</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> N<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    \n    <span class=\"token comment\"># appels récursifs</span>\n    <span class=\"token keyword\">return</span> fusion<span class=\"token punctuation\">(</span>tri_fusion<span class=\"token punctuation\">(</span>tbl1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> tri_fusion<span class=\"token punctuation\">(</span>tbl2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>On fait un petit test sur une liste quelconque.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">>>> tri_fusion([0, 25, 36, 41, 1, 465, 2, 3, 987])\n[0, 1, 2, 3, 25, 36, 41, 465, 987]</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h3 id=\"conclusion\" style=\"position:relative;\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h3>\n<p>Nous avons vu dans ce chapitre un algorithme particulièrement <em>élégant\net efficace</em> pour trier des éléments. Bien sûr, dans la pratique des\ncontraintes de mémoire peuvent intervenir, et là au contraire cet\nalgorithme se révélera peu performant, car l'utilisation de la\nrécursivité et du tableau intermédiaire le rend très gourmand en\nmémoire.</p>\n<p>La méthode «diviser pour régner» est une méthode très efficace pour\nrésoudre des problèmes complexes en les <em>découpant en sous problèmes\nindépendants</em>. Par contre, on verra dans le prochain chapitre qu'elle\ndevient inefficace si les sous-problèmes se chevauchent, et il\nconviendra alors d'utiliser une nouvelle technique appelée <em>«\nProgrammation dynamique »</em> qui sera étudiée dans le chapitre\n<span><a href=\"/2021-2022/tg/nsi/5-algorithmique/4-programmation-dynamique\">P5C4</a></span>.</p>\n<div class=\"ref\">\n<ul>\n<li><span><a href=\"https://fr.wikipedia.org/wiki/Diviser_pour_r%C3%A9gner_(informatique)\">Article Wikipedia Diviser pour\nrégner</a></span></li>\n<li><span><a href=\"https://editions.lavoisier.fr/etudes-superieures/informatique-mp-pc-pt-psi/preaux/tec-et-doc/le-tout-en-un/livre/9782743022976\">Informatique\nMP-PC-PT-PSI</a></span></li>\n</ul>\n</div>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#complexit%C3%A9-des-algorithmes-de-tri\">Complexité des algorithmes de tri</a></p>\n</li>\n<li>\n<p><a href=\"#le-principe-de-diviser-pour-r%C3%A9gner\">Le principe de diviser pour régner</a></p>\n</li>\n<li>\n<p><a href=\"#le-tri-fusion\">Le tri fusion</a></p>\n<ul>\n<li><a href=\"#algorithme-de-fusion\">Algorithme de fusion</a></li>\n<li><a href=\"#algorithme-de-tri-fusion\">Algorithme de tri fusion</a></li>\n<li><a href=\"#conclusion\">Conclusion</a></li>\n</ul>\n</li>\n</ul>","frontmatter":{"tags":["cours","terminale","lycée","numérique et sciences informatiques","nsi"]},"fields":{"classe":"tg","chapter":"Diviser pour régner","matter":"nsi","nChapter":"2","part":"Algorithmique","nPart":"5"}}},"pageContext":{"slug":"tg/nsi/5-algorithmique/2-diviser-pour-regner","chapter":"Diviser pour régner"}},"staticQueryHashes":["604483588"]}