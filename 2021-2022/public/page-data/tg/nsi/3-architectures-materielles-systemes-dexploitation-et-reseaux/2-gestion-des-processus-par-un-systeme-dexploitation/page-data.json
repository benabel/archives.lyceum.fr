{"componentChunkName":"component---src-templates-cours-md-js","path":"/tg/nsi/3-architectures-materielles-systemes-dexploitation-et-reseaux/2-gestion-des-processus-par-un-systeme-dexploitation","result":{"data":{"markdownRemark":{"html":"<details class=\"programme\">\n<summary>\nProgramme Officiel\n</summary>\n<table class=\"table table-bordered table-hover\">\n<thead class=\"table-warning\">\n<tr class=\"header\">\n<th>\nContenus\n</th>\n<th>\nCapacités attendues\n</th>\n<th>\nCommentaires\n</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>\nGestion des processus et des ressources par un système d'exploitation.\n</td>\n<td>\n<p>\nDécrire la création d'un processus, l'ordonnancement de plusieurs\nprocessus par le système.\n</p>\n<p>\nMettre en évidence le risque de l'interblocage (deadlock).\n</p>\n</td>\n<td>\nÀ l'aide d'outils standard, il s'agit d'observer les processus actifs ou\nen attente sur une machine. Une présentation débranchée de\nl'interblocage peut être proposée.\n</td>\n</tr>\n</tbody>\n</table>\n<a class=\"lien-programme\" href=\"../programme/\">Lien vers le programme\ncomplet</a>\n</details>\n<blockquote>\n<p>Comme nous l'avons vu en première, le <span><a href=\"/2021-2022/1g/nsi/6-architectures-materielles-et-systemes-dexploitation/3-systemes-dexploitation/\">système\nd'exploitation</a></span>(Linux,\nWindows, MacOs...) est un programme particulier situé entre le\nmatériel et les applications qui a pour de rôle de coordonner\nl'ensemble des tâches qui sont exécutées par l'ordinateur. Cette\nannée, nous allons voir comment le système d'exploitation charge les\nprogrammes dans la mémoire de masse et lance leur <em>exécution</em> en leur\ncréant des <strong>processus</strong> afin de pouvoir les gérer lors de leur\nexécution.</p>\n</blockquote>\n<h2 id=\"différence-entre-programme-et-processus\" style=\"position:relative;\"><a href=\"#diff%C3%A9rence-entre-programme-et-processus\" aria-label=\"différence entre programme et processus permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Différence entre programme et processus</h2>\n<dl>\n<dt>\nProgramme\n</dt>\n<dd>\n<div>\n<p>Un <strong>programme est statique</strong>: c'est un fichier contenant une suite\nd'instructions qui lorsqu'elles sont exécutées modifient l'état du\nprocesseur et de la mémoire afin de réaliser une tâche donnée.</p>\n</div>\n</dd>\n</dl>\n<p>Un même programme peut-être exécuté <em>plusieurs fois</em> sur une même\nmachine, il faut alors allouer à chacune de ces exécutions des\nressources de mémoire et de processeur distinctes au cours de ces\nexécutions. C'est le système d'exploitation qui gère l'allocation de ces\nressources.</p>\n<dl>\n<dt>\nProcessus\n</dt>\n<dd>\n<div>\n<p>Un <strong>processus est dynamique</strong>: c'est une instance d'exécution d'un\nprogramme sur une machine de son lancement jusqu'à sa fin.</p>\n</div>\n</dd>\n</dl>\n<p>Les systèmes d'exploitation permettent à l'utilisateur de visualiser et\ngérer les processus grâce à un <strong>gestionnaire de processus</strong>.</p>\n<details class=\"appli\">\n<summary>\nProgrammes et processus sous linux\n</summary>\n<!-- TODO personnaliser image docker de binder -->\n<p>Si vous êtes sous linux ou OSX, vous pouvez simplement lancer un\nterminal pour ouvrir une console. Sinon vous pouvez lancer une instance\njupyterlab en ligne grâce à Binder.</p>\n<p><span><a href=\"https://mybinder.org/v2/gh/binder-examples/jupyterlab/master?urlpath=lab/tree/index.ipynb\"><span><img src=\"http://mybinder.org/badge_logo.svg\" alt=\"Binder\"></span></a></span></p>\n<p>Sous linux, les programmes sont par\n<span><a href=\"https://fr.wikipedia.org/wiki/Filesystem_Hierarchy_Standard\">convention</a></span>\nsituées dans les dossiers <code class=\"language-text\">bin</code> pour binaries en anglais:</p>\n<ul>\n<li><code class=\"language-text\">/bin/</code>: commandes de base nécessaires au démarrage et à\nl'utilisation d'un système minimaliste.</li>\n<li><code class=\"language-text\">/sbin/</code>: Exécutables pour les administrateurs (abréviation de\nsystem binaries, soit binaires système en français).</li>\n<li><code class=\"language-text\">/usr/bin/</code>: Binaires exécutables qui ne sont pas déjà présents dans\n<code class=\"language-text\">/bin</code> et donc pas indispensables à un système minimaliste.</li>\n</ul>\n<p>On peut <strong>lister les programmes</strong> avec la commande <code class=\"language-text\">ls</code> et les exécuter\nen tapant leur nom dans une console.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\"><span class=\"token comment\"># la commande ls vue en première (abbréviation de list en anglais)</span>\n<span class=\"token function\">ls</span> /bin\n\n<span class=\"token function\">ls</span> /sbin\n\n<span class=\"token function\">ls</span> /usr/bin</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Vous pouvez <strong>afficher un programme</strong> en particulier grâce à la commande\n<code class=\"language-text\">cat</code>.</p>\n<p><code class=\"language-text\">cat /bin/ls</code></p>\n<p>Comme vous le voyez c'est un fichier binaire car ce programme a été\ncompilé pour s'exécuter plus rapidement.</p>\n<p>Vous pouvez <strong>lancer un programme</strong> en particulier en écrivant son <code class=\"language-text\">nom</code>\n(sans préciser son chemin s'il appartient au <code class=\"language-text\">PATH</code>).</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\"><span class=\"token comment\"># affichage sortie</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Voulez-vous continuer\"</span>\n<span class=\"token comment\"># lecture entrée</span>\n<span class=\"token builtin class-name\">read</span> </code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Maintenant si vous voulez <strong>lister les processus</strong> en cours d'exécution\non utilise la commande <code class=\"language-text\">ps</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-shell line-numbers\"><code class=\"language-shell\"><span class=\"token comment\"># affiche mes processus en exécution</span>\n<span class=\"token function\">ps</span>\n<span class=\"token comment\"># affiche tous les processus</span>\n<span class=\"token function\">ps</span> <span class=\"token parameter variable\">-A</span>\n<span class=\"token comment\"># affiche une aide simple</span>\n<span class=\"token function\">ps</span> <span class=\"token parameter variable\">--help</span> s</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Voici un exemple de sortie avec l'option <code class=\"language-text\">-l</code> pour obtenir plus détails:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">jovyan@jupyter-jupyterlab-2djupyterlab-2ddemo-2dgmyobfo6:~$ ps -lA\nF S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD\n4 S  1000       1       0  0  80   0 - 137942 epoll_ ?       00:00:45 jupyter-noteboo\n0 Z  1000    2293       1  0  80   0 -     0 -      ?        00:00:00 dash &lt;defunct>\n4 S  1000    4031       1  0  80   0 -  5116 wait   pts/0    00:00:00 bash\n4 S  1000    4900    4031  0  80   0 -  5083 select pts/0    00:00:00 bash\n4 S  1000    5105       1  0  80   0 -  5116 wait   pts/1    00:00:00 bash\n0 R  1000    5984    5105  0  80   0 -  6910 -      pts/1    00:00:00 ps</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>On peut créer des affichages particuliers par exemple pour voir quels\nprocessus sont les plus gourmands en mémoire:\n<code class=\"language-text\">ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem | head</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">PID    PPID CMD                         %MEM %CPU\n  1       0 /srv/conda/envs/notebook/bi  0.1 17.0\n122       1 /srv/conda/envs/notebook/bi  0.0  4.6\n 84       1 /bin/bash -l                 0.0  1.7\n137      84 ps -eo pid,ppid,cmd,%mem,%c  0.0  0.0\n138      84 head                         0.0  0.0</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Enfin on peut <strong>tuer un processus</strong> avec la commande <code class=\"language-text\">kill</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\"># tuer avec le PID processus id\nkill 122\n# tuer par le nom du programme ATTENTION cela tue votre instance binder\n# pkill jupyter </code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n</details>\n<h2 id=\"les-états-dun-processus\" style=\"position:relative;\"><a href=\"#les-%C3%A9tats-dun-processus\" aria-label=\"les états dun processus permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Les états d'un processus</h2>\n<p>Un processus n'a pas seulement besoin d'accéder au processeur, mais il a\nsouvent besoin d'accéder à des <em>ressources</em> autres comme:</p>\n<ul>\n<li>La mémoire vive: RAM,</li>\n<li>La mémoire de masse: disques durs, clés USB, mémoire flash...</li>\n<li>La lecture ou l'écriture d'un fichier...</li>\n<li>Les périphériques d'entrée et de sortie: clavier, souris, écran,\nimprimante...</li>\n</ul>\n<p>Ces <em>ressources</em> externes étant beaucoup moins rapides que le\nprocesseur, elles <strong>bloquent</strong> les processus lors de leur exécution.</p>\n<p>Ainsi, lors de la vie d'un processus, celui-ci peut passer par trois\nétats:</p>\n<ul>\n<li><strong>PRÊT</strong>: le processus est lancé et <em>attend l'accès au processeur</em>.</li>\n<li><strong>ÉLU</strong>: le processus a obtenu l'accès au processeur: il peut\ns'exécuter.</li>\n<li><strong>BLOQUÉ</strong>: le processus est en cours d'exécution, mais <em>attend une\nressource</em> en mémoire par exemple, il quitte le processeur pour\nlibérer les ressources.</li>\n</ul>\n<p><wc-wikimage class=\"half center\" title=\"Diagrammedétatdunprocessus_1.png\" caption=\"Les trois états d'un processus, et le passage d'un état à un autre.\"></wc-wikimage></p>\n<h2 id=\"ordonnancement\" style=\"position:relative;\"><a href=\"#ordonnancement\" aria-label=\"ordonnancement permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Ordonnancement</h2>\n<p>À un instant donné, il y a souvent davantage de processus à exécuter que\nde processeurs.</p>\n<p>Lors de leur lacement les processus sont placés dans une\n<span><a href=\"/2021-2022/tg/nsi/1-structures-de-donnees/3-structures-lineaires-piles-files\">file</a></span>\nd'attente.</p>\n<p>L'ordonnanceur désigne le composant du noyau du système d'exploitation\nchoisissant l'ordre d'exécution des processus sur les processeurs d'un\nordinateur.</p>\n<p>Il existe divers algorithmes d'ordonnancement:</p>\n<ul>\n<li><strong>La méthode du tourniquet</strong> (<em>Round Robin</em>): l'ordonnanceur traite\nla file d'attente comme une file circulaire et alloue successivement\nun temps processeur à chacun des processus de la file.</li>\n<li><strong>FIFO</strong>: First In First Out (voir le <span><a href=\"/2021-2022/tg/nsi/1-structures-de-donnees/3-structures-lineaires-piles-files\">cours sur les\nfiles</a></span>)</li>\n<li><strong>SJF</strong> Shortest job first (SJF, ou SJN -Shortest Job Next-).</li>\n<li>...</li>\n</ul>\n<p>[<span><a href=\"https://fr.wikipedia.org/wiki/Ordonnancement_dans_les_syst%C3%A8mes_d&#x27;exploitation\">Article Wikipédia sur\nl'ordonnancement</a></span>]{.cite-source}</p>\n<h2 id=\"interblocage\" style=\"position:relative;\"><a href=\"#interblocage\" aria-label=\"interblocage permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Interblocage</h2>\n<dl>\n<dt>\ninterblocage\n</dt>\n<dd>\n<div>\n<p>Un interblocage (ou étreinte fatale, <em>deadlock</em> en anglais pour impasse)\nest un phénomène qui peut se produire en programmation concurrente\nlorsque des processus s'attendent mutuellement.</p>\n</div>\n</dd>\n</dl>\n<div class=\"example\">\n<p>Un exemple concret d'interblocage peut se produire lorsque deux\nprocessus essayent d'acquérir deux ressources dans un ordre différent.</p>\n<a href=\"https://commons.wikimedia.org/wiki/File:Process_deadlock.svg#/media/File:Process_deadlock.svg\">\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/2/28/Process_deadlock.svg/1200px-Process_deadlock.svg.png\" alt=\"Process deadlock.svg\"></a>\n<ul>\n<li>P1 acquiert R1.</li>\n<li>P2 acquiert R2.</li>\n<li>P1 attend pour acquérir R2 (qui est détenu par P2).</li>\n<li>P2 attend pour acquérir R1 (qui est détenu par P1).</li>\n</ul>\n<p>Dans cette situation, les deux processus sont définitivement bloqués.</p>\n</div>\n<div class=\"example\">\n<p>Deux processus en concurrence pour deux ressources dans un ordre opposé.</p>\n<p>\n<a href=\"https://commons.wikimedia.org/wiki/File:Two_processes,_two_resources.gif#/media/File:Two_processes,_two_resources.gif\"><img src=\"https://upload.wikimedia.org/wikipedia/commons/d/df/Two_processes%2C_two_resources.gif\" alt=\"Two processes, two resources.gif\"></a><br>By\n<a href=\"//commons.wikimedia.org/w/index.php?title=User:Abacoo&amp;amp;action=edit&amp;amp;redlink=1\" class=\"new\" title=\"User:Abacoo (page does not exist)\">Abacoo</a> -\n[Own work]{.int-own-work lang=\"en\"},\n<a href=\"https://creativecommons.org/licenses/by-sa/4.0\" title=\"Creative Commons Attribution-Share Alike 4.0\">CC\nBY-SA 4.0</a>,\n<a href=\"https://commons.wikimedia.org/w/index.php?curid=47971211\">Link</a>\n</p>\n<ul>\n<li><strong>A</strong> Un seul processus se déroule.</li>\n<li><strong>B</strong> Le processus ultérieur doit attendre.</li>\n<li><strong>C</strong> Un blocage se produit lorsque le premier processus verrouille\nla première ressource en même temps que le second processus\nverrouille la seconde ressource.</li>\n<li><strong>D</strong> Le blocage peut être résolu en annulant et en redémarrant le\npremier processus.</li>\n</ul>\n</div>\n<p>Il existe plusieurs façons de gérer les interblocages:</p>\n<ul>\n<li>les <em>ignorer</em> ce qui était fait initialement par UNIX qui supposait\nque la fréquence des interblocages était faible et que la perte de\ndonnées encourue à chaque fois est tolérable.</li>\n<li>les <em>détecter</em>: Un algorithme est utilisé pour suivre l'allocation\ndes ressources et les états des processus, il annule et redémarre un\nou plusieurs processus afin de supprimer le blocage détecté</li>\n<li>les <em>éviter</em>: des\n<span><a href=\"https://en.wikipedia.org/wiki/Deadlock_prevention_algorithms\">algorithmes</a></span>\nsont utilisés pour supprimer une des quatre conditions nécessaires à\nla possibilité de l'interblocage(<span><a href=\"https://fr.wikipedia.org/wiki/Interblocage#Conditions_n%C3%A9cessaires\">Conditions de\nCoffman</a></span>)</li>\n</ul>\n<details class=\"plus\">\n<summary>\nConditions de Coffman\n</summary>\n<p>Coffman a prouvé en 1971 qu'il y a quatre conditions nécessaires pour\nqu'un blocage puisse avoir lieu.</p>\n<p>Voir l'article Wikipédia <span><a href=\"https://fr.wikipedia.org/wiki/Interblocage#Conditions_n%C3%A9cessaires\">Conditions de\nCoffman</a></span>\npour plus de détails.</p>\n</details>","tableOfContents":"<ul>\n<li><a href=\"#diff%C3%A9rence-entre-programme-et-processus\">Différence entre programme et processus</a></li>\n<li><a href=\"#les-%C3%A9tats-dun-processus\">Les états d'un processus</a></li>\n<li><a href=\"#ordonnancement\">Ordonnancement</a></li>\n<li><a href=\"#interblocage\">Interblocage</a></li>\n</ul>","frontmatter":{"tags":["cours","terminale","lycée","numérique et sciences informatiques","nsi"]},"fields":{"classe":"tg","chapter":"Gestion des processus par un système d'exploitation","matter":"nsi","nChapter":"2","part":"Architectures matérielles, systèmes d’exploitation et réseaux","nPart":"3"}}},"pageContext":{"slug":"tg/nsi/3-architectures-materielles-systemes-dexploitation-et-reseaux/2-gestion-des-processus-par-un-systeme-dexploitation","chapter":"Gestion des processus par un système d'exploitation"}},"staticQueryHashes":["604483588"]}