---
title: Exercices
subtitle: "Chapitre 2: Jeu d’instructions du processeur"
exo: true
type: exo
tabnav: true
---
Rappels des instructions utilisées dans ce cours.

+-------------+--------+---------------------------------------------------------------------------------------------+
| instruction | codage | signification                                                                               |
+=============+========+=============================================================================================+
| LDA         | 0      | Charge l'état de la case mémoire donnée en argument dans le registre A.                     |
+-------------+--------+---------------------------------------------------------------------------------------------+
| LDB         | 1      | Charge l'état de la case mémoire donnée en argument dans le registre B.                     |
+-------------+--------+---------------------------------------------------------------------------------------------+
| STA         | 2      | Stocke l'état du registre A dans la case mémoire donnée en argument.                        |
+-------------+--------+---------------------------------------------------------------------------------------------+
| STB         | 3      | Stocke l'état du registre B dans la case mémoire donnée en argument.                        |
+-------------+--------+---------------------------------------------------------------------------------------------+
| ADD         | 4      | Additionne le contenu des registres et le stocke dans le registre donné en argument.        |
+-------------+--------+---------------------------------------------------------------------------------------------+
| DEC         | 5      | Décrémente la valeur contenue dans le registre donné en argument, c'est à dire soustrait 1. |
+-------------+--------+---------------------------------------------------------------------------------------------+
| JMP         | 6      | Fait "sauter"(JUMP) le programme vers une ligne donnée en argument                          |
+-------------+--------+---------------------------------------------------------------------------------------------+
| JMPZ        | 7      | Comme JUMP, mais uniquement si le registre A est 0.                                         |
+-------------+--------+---------------------------------------------------------------------------------------------+
| END         | 8      | Termine le programme                                                                        |
+-------------+--------+---------------------------------------------------------------------------------------------+

## Addition simple

Écrire une séquence d'instructions qui multiplie par 5 le nombre contenu dans la case mémoire 10 et
stocke le résultat dans la case mémoire 11.

Traduire les instrcuctions en langage machine binaire avec des mots de 4 bits(3= `0011` par
exemple).


## Différence

Écrire un programme qui lit deux valeurs x et y contenues respectivement dans les cases mémoires 11
et 12, calcule la différence $y - x$ et stocke le résultat à l’adresse 13. On suppose que ces deux
valeurs sont des nombres entiers positifs.

Compléter ce programme pour qu’il stocke la valeur 0 à l’adresse 15 si x est égal à y, ou la valeur
x sinon.

## Multiplication

Écrire un programme qui multiplie la valeur contenue à la case mémoire 12 par celle contenue dans
la case mémoire 13 et stocke le résultat à l’adresse 14. On suppose que ces valeurs sont des
nombres entiers positifs.

Quel problème l’écriture de ce programme pose-t-elle ? Quelle modification du processeur
permettrait de contourner ce problème et donc de simplifier le programme ?


## TP: Ecrire de l'assembleur sur un simulateur

La page suivante propose d'écrire quelques programmes en assembleur.

<https://pixees.fr/informatiquelycee/n_site/nsi_prem_sim_cpu.html>

Elle utilise la simulation de Peter Higginson qui simule le langage assembleur AQA.

http://www.peterhigginson.co.uk/AQA/

<!-- ### De python à l'assembleur

 Voici un programme Python très simple :

```
x = 4
y = 8
if x == 10:
	y = 9
else :
	x=x+1
z=6
```
			

et voici maintenant voici son équivalent en assembleur :

```asm
   MOV R0, #4
   STR R0,30
   MOV R0, #8
   STR R0,75
   LDR R0,30
   CMP R0, #10
   BNE else
   MOV R0, #9
   STR R0,75
   B endif
else:
   LDR R0,30
   ADD R0, R0, #1
   STR R0,30
endif:
   MOV R0, #6
   STR R0,23
   HALT
```			

Après avoir analysé très attentivement le programme en assembleur ci-dessus, vous essaierez
d'établir une correspondance entre les lignes du programme en Python et les lignes du programme en
assembleur. À quoi sert la ligne "B endif" ? À quoi correspondent les adresses mémoires 23, 75 et
30 ?

Source: pixees.fr CC-BY-SA


### AIDE: L'ensemble d'instructions AQA

Voici une traduction de la documentation proposée à partir du bouton [INFO](http://www.peterhigginson.co.uk/AQA/info.html)

Les registres sont numérotés de `R0` à `R12`.

Les opérations peuvent être effectuées sur deux types de valeurs (notées `<opérande2>` dans la suite):

- une constante notée `#nnn`. Ex: `#12`: la valeur décimale 12.
- le contenu du régistre n `Rn`. Ex: `R1`: la valeur contenie dans le registre 1.

On peut ajouter des étiquettes dans le programme (notées `<label>`); il suffit de noter le nom de
l'étiquette de son choix et de le faire suivre de deux points. 

exemple:

```asm test: ```

Toute référence à cette étiquette fera "sauter" le programme à la case mémoire de
l'étiquette et exécutera donc les instructions qui suivent.

les commentaires commencent par au moins un `/`.

### Affectations

- `LDR Rd, <adresse mémoire>`

Charge la valeur stockée dans l'emplacement de mémoire spécifié par `<adresse mémoire>` dans le
registre d.

- `STR Rd, <adresse mémoire>`

Stocke la valeur qui se trouve dans le registre d dans l'emplacement de mémoire spécifié par
`<adresse mémoire>`.

- `MOV Rd, <opérande2>`

Copiez la valeur spécifiée par `<opérande 2>`dans le registre d.


### Opérations

- `ADD Rd, Rn, <opérande2>`

Ajouter la valeur spécifiée dans `<opérande 2>`à la valeur du registre 
n et stocker le résultat dans le registre d.

- `SUB Rd, Rn, <opérande2>`

Soustrayez la valeur spécifiée par `<opérande 2>`de la valeur du 
registre n et stockez le résultat dans le registre d.

### Comparaisons

- `CMP Rn, <opérande2>`

Comparez la valeur stockée dans le registre n avec la valeur spécifiée 
par `<opérande 2>`

- `B <condition> <label>`

Connectez conditionnellement l'instruction à la position `<label>` dans
le programme si la dernière comparaison a répondu aux critères spécifiés par la `<condition>`. Les
valeurs possibles pour `<condition>` et leur signification sont les suivantes:
   - `EQ`: égal à,
   - `NE`: différent de,
   - `GT`: supérieur à,
   - `LT`: inférieur à. 

### Sauts(JUMP)

- `B <label>`

Toujours relier l'instruction à la position `<label>` dans le programme.

### Fin du programme

- `HALT`: Arrête l'exécution du programme.

### Non utilisées dans ce TD

- `AND Rd, Rn, <opérande2>`:

Effectue une opération ET logique au niveau du bit entre la valeur du 
registre n et la valeur spécifiée par `<opérande 2>` et stocke le résultat dans le registre d.

- `ORR Rd, Rn, <opérande2>`:

Effectue une opération OU logique au niveau des bits entre la
valeur du registre n et la valeur spécifiée par `<opérande 2>`et stocke le résultat dans le registre
d.

- `EOR Rd, Rn, <opérande2>`:

Effectue une opération logique ou binaire exclusive au sens des bits
entre la valeur du registre n et la valeur spécifiée par `<opérande 2>`et stocke le résultat dans le
registre d.

- `MVN Rd, <opérande2>`:

Exécutez une opération NOT logique au niveau des bits sur la valeur
spécifiée par `<opérande 2>`et stockez le résultat dans le registre d.

- `LSL Rd, Rn, <opérande2>`:

Décalez logiquement vers la gauche la valeur stockée dans le registre
n du nombre de bits spécifié par `<opérande 2>` et stockez le résultat dans le registre d.

- `LSR Rd, Rn, <opérande2>`:

Décalez logiquement à droite la valeur stockée dans le registre n du 
nombre de bits spécifié par `<opérande 2>` et stockez le résultat dans le registre d. -->

::: ref

-   Chapitre 15: L'organisation d'un ordinateur [Informatique et sciences du numérique Spécialité ISN en terminale S - Avec des exercices corrigés et des idées de projets par Gilles Dowek](http://www.editions-eyrolles.com/Livre/9782212135435/)
- https://pixees.fr/informatiquelycee/n_site/nsi_prem_sim_cpu.html
- http://www.lyceerotroudreux.com/images/NSI/Langage_Assembleur.pdf
- http://www.peterhigginson.co.uk/AQA/info.html

:::