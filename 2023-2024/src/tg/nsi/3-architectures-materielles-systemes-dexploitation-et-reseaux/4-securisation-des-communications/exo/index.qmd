---
title: Exercices
subtitle: "Chapitre 4: Sécurisation des communications*"
exo: true
type: exo
tabnav: true
---
Pour réaliser ces exercices on peut utiliser le module `string` de python.

```python
# crée une chaîne de caractères avec l'alphabet

from string import ascii_uppercase as alphabet
print(alphabet)     # affiche ABCDEFGHIJKLMNOPQRSTUVWXYZ

# accès aux caractères par l'index
alphabet[0], alphabet[25]     # renvoie "A", "Z"

# recherche d'un caractère
alphabet.index("A"), alphabet.index("Z")     # renvoie 0, 25

# Méthode str.upper pour mettre une chaîne de caractère en majuscules
"Message".upper()   # renvoie "MESSAGE"
```

## Implémenter des chiffrements symétriques en Python

1. Implémenter le **chiffrement de César** en créant une fonction `cesar` qui prend deux paramètres:

   - `message` une chaîne de caractères à (dé)coder.
   - `n` un entier qui donne le décalage.

   Cette fonction doit convertir le message en majuscule, et décaler toutes les lettres de $n$ grâce au codage César, et laisser tous les autres caractères inchangés(ponctuation).

   Voici une série de tests à passer.

   ```python
   assert cesar('message', 0) == "MESSAGE"
   assert cesar('message', 1) == 'NFTTBHF'
   assert cesar('message', -1) == 'LDRRZFD'
   assert cesar('message', 26) == 'MESSAGE'
   assert cesar('message', 53) == 'NFTTBHF'
   assert cesar('message', -27) == 'LDRRZFD'
   
   eluard = """Sur mes cahiers d’écolier
   Sur mon pupitre et les arbres
   Sur le sable sur la neige
   J’écris ton nom"""
   assert cesar(eluard, 13) == 'FHE ZRF PNUVREF Q’ÉPBYVRE\nFHE ZBA CHCVGER RG YRF NEOERF\nFHE YR FNOYR FHE YN ARVTR\nW’ÉPEVF GBA ABZ'
   
   # vérification du décodage
   assert cesar(cesar(eluard, 13), -13) == eluard.upper()
   ```
<!-- 
   ```python
   def cesar(message, n):
    m = message.upper()
    codage = ""
    for lettre in m:
        if lettre in alphabet:
            index = (alphabet.index(lettre) + n) % len(alphabet)
            codage += alphabet[index]
        else:
            codage += lettre
    return codage
    ``` -->
   
2. Implémenter le **chiffrement par substitution** avec une fonction `substitution` qui prend deux paramètres:

   - `message` une chaîne de caractères à (dé)coder.
   - `clé` une chaîne de caractères qui donne les correspondances des caractères. Par exemple: `AZERTYUIOPQSDFGHJKLMWXCVBN` dans le cours.

   On pourra vérifier son fonctionnement sur l'exemple du cours:
   
   ```python
   assert substitution("SUBSTITUTION", "AZERTYUIOPQSDFGHJKLMWXCVBN") == "LWZLMOMWMOGF"
   ```

   Comment devra être effectué le décodage à partir du message codé et de la clé?

3. Implémenter le **chiffrement de Vigenère** avec une fonction `vigenère` qui prend deux paramètres:

   - `message` une chaîne de caractères à (dé)coder.
   - `clé` une chaîne de caractères qui donne les décalages des caractères. Par exemple: `ABC` dans le cours.

   On pourra vérifier son fonctionnement sur l'exemple du cours:
   
   ```python
   assert vigenère("SUBSTITUTION", "ABC") == "SVDSUKTVVIPP"
   ```

   Comment devra être effectué le décodage à partir du message codé et de la clé?

   
